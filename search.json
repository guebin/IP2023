[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "파이썬프로그래밍\nguebin@jbnu.ac.kr\n자연과학대학 본관 205호"
  },
  {
    "objectID": "posts/04_Appendix/2022-06-14-final.html",
    "href": "posts/04_Appendix/2022-06-14-final.html",
    "title": "참고자료: 2022-06-final",
    "section": "",
    "text": "오픈 북, 2시간, 문제미리공개"
  },
  {
    "objectID": "posts/04_Appendix/2022-06-14-final.html#imports",
    "href": "posts/04_Appendix/2022-06-14-final.html#imports",
    "title": "참고자료: 2022-06-final",
    "section": "0. imports",
    "text": "0. imports\n아래코드를 이용하여 numpy, matplotlib, pandas를 import하라.\n\nimport numpy as np\nimport matplotlib.pyplot as plt \nimport pandas as pd\nfrom IPython.display import HTML"
  },
  {
    "objectID": "posts/04_Appendix/2022-06-14-final.html#기본문제-50점",
    "href": "posts/04_Appendix/2022-06-14-final.html#기본문제-50점",
    "title": "참고자료: 2022-06-final",
    "section": "1. 기본문제 (50점)",
    "text": "1. 기본문제 (50점)\n(1) 도함수를 구하는 함수 derivate를 선언하라. 이 함수를 이용하여 \\(f(x)=x^2\\)의 그래프와 \\(f'(x)=2x\\)의 그래프를 \\(x \\in (-1,1)\\)의 범위에서 그려라.\n(풀이)\n\ndef f(x): \n    return x**2 \n\n\ndef derivate(f): \n    def df(x): \n        h=0.000000000001\n        return (f(x+h)-f(x))/h \n    return df\n\n\nx = np.linspace(-1,1,100)\nplt.plot(x,f(x))\nplt.plot(x,derivate(f)(x))\n\n\n\n\n(2) 적당한 클래스 정의하여 인스턴스 a를 만들고 print(a)의 출력결과가 본인의 학번이 나오도록 하라.\n(풀이)\n\nclass Klass:\n    def __str__(self):\n        return('2022-43052')\n\n\na=Klass()\nprint(a)\n\n2022-43052\n\n\n(3) for문이 실행될때마다 [묵,찌,빠] 중에 하나를 내며 빠를 누적 3회 낼경우 for문이 멈추는 이터레이터를 생성하라.\n(풀이)\n\nclass Klass: # 찌를 내는순간 for문이 멈추도록 하는 이터레이터를 만들자\n    def __init__(self): \n        self.candidate = [\"묵\",\"찌\",\"빠\"] \n        self.dic = {'묵':0,'찌':0,'빠':0}\n    def __iter__(self):\n        return self \n    def __next__(self):\n        action = np.random.choice(self.candidate)\n        self.dic[action] += 1\n        if self.dic['빠']==3:\n            print(\"빠가 3번 누적되어 for문을 멈춥니다\")\n            raise StopIteration\n        else:\n            return action\n\n\na=Klass()\nfor i in a:\n    print(i)\n\n빠\n묵\n빠\n빠가 3번 누적되어 for문을 멈춥니다\n\n\n(4)-(6)\n\nclass GS25: \n    n=0 \n    total_number_of_guests = 0 \n    def __init__(self):\n        self.number_of_guests = 0 \n\n(4) 위의 클래스를 수정하여 아래와 같이 GS25에서 새로운 인스턴스가 생성될때마다\nGS25의 점포수가 ?개로 늘었습니다.\n라는 메시지가 출력되도록 하라.\n(5) 함수 come를 인스턴스 메소드로 정의하라. 이 메소드가 실행될때마다 각 점포의 손님 인스턴스 변수 number_of_guests와 클래스변수 total_number_of_guests를 1씩 증가시키고 아래의 메시지를 출력하라.\n새로운 손님이 오셨습니다!\nGS25를 방문한 총 손님수는 n명입니다. \n현재 GS25 점포를 방문한 손님수는 m명입니다. \n(6) 새로운 클래스메서드 show를 만들고 아래와 같은 메시지를 출력하도록 하라.\nGS25의 점포수: ??\nGS25를 방문한 총 손님수: ??\n(풀이)\n\nclass GS25: \n    n=0 \n    total_number_of_guests = 0 \n    def __init__(self):\n        self.number_of_guests = 0 \n        GS25.n += 1 \n        print(\"GS25의 점포수가 {}개로 늘었습니다.\".format(GS25.n))\n    def come(self):\n        GS25.total_number_of_guests += 1 \n        self.number_of_guests += 1\n        print(\"새로운 손님이 오셨습니다!\")\n        print(\"GS25를 방문한 총 손님수는 {}명입니다.\".format(GS25.total_number_of_guests))\n        print(\"현재 GS25 점포를 방문한 손님수는 {}명입니다.\".format(self.number_of_guests))\n    @classmethod\n    def show(cls):\n        print(\"GS25의 점포수: {}\".format(cls.n))\n        print(\"GS25를 방문한 총 손님수: {}\".format(cls.total_number_of_guests))\n\n\na=GS25() ## (4)의 사용예시\n\nGS25의 점포수가 1개로 늘었습니다.\n\n\n\nb=GS25() ## (4)의 사용예시\n\nGS25의 점포수가 2개로 늘었습니다.\n\n\n\na.come() ## (5)의 사용예시\n\n새로운 손님이 오셨습니다!\nGS25를 방문한 총 손님수는 1명입니다.\n현재 GS25 점포를 방문한 손님수는 1명입니다.\n\n\n\na.come() ## (5)의 사용예시\n\n새로운 손님이 오셨습니다!\nGS25를 방문한 총 손님수는 2명입니다.\n현재 GS25 점포를 방문한 손님수는 2명입니다.\n\n\n\nb.come() ## (5)의 사용예시\n\n새로운 손님이 오셨습니다!\nGS25를 방문한 총 손님수는 3명입니다.\n현재 GS25 점포를 방문한 손님수는 1명입니다.\n\n\n\nGS25.show() ## (6)의 사용예시\n\nGS25의 점포수: 2\nGS25를 방문한 총 손님수: 3\n\n\n(7) __eq__는 연산 == 를 재정의하는 메소드이다. 클래스 RPS_BASE를 상속하여 새로운 클래스 RPS5를 만들라. 연산 ==를 재정의하여 RPS7의 두 인스턴스의 action이 같은 경우 true를 리턴하는 기능을 구현하라.\n\nclass RPS_BASE:\n    def __init__(self):\n        self.action = np.random.choice(['가위','바위','보'])\n\n(풀이)\n\nclass RPS7(RPS_BASE):\n    def __eq__(self,other):\n        return self.action == other.action \n\n\na=RPS7()\na.action\n\n'바위'\n\n\n\nb=RPS7()\nb.action\n\n'가위'\n\n\n\na==b\n\nFalse\n\n\n(8) __gt__는 연산 > 를 재정의하는 메소드이다. 클래스 RPS_BASE를 상속하여 새로운 클래스 RPS6를 만들라. 연산 >를 재정의하여 RPS6의 두 인스턴스 a,b의 action이 각각 (‘가위’,‘보’), (‘바위’,‘가위’), (‘보’,‘바위’) 인 경우 true를 리턴하는 기능을 구현하라.\n(풀이)\n\nclass RPS8(RPS_BASE):\n    def __gt__(self,other): # 연산 > 를 재정의 \n        pair = self.action, other.action\n        return pair == ('가위','보') or pair == ('바위','가위') or pair == ('보','바위') \n\n\na=RPS8()\na.action\n\n'보'\n\n\n\nb=RPS8()\nb.action\n\n'가위'\n\n\n\na>b, a<b\n\n(False, True)\n\n\n(9)-(10)\n아래와 같은 데이터프레임을 선언하고 물음에 답하라.\n\nnp.random.seed(43052)\ndf=pd.DataFrame({'type':np.random.choice(['A','B'],100), 'score':np.random.randint(40,95,100)})\ndf\n\n\n\n\n\n  \n    \n      \n      type\n      score\n    \n  \n  \n    \n      0\n      B\n      45\n    \n    \n      1\n      A\n      40\n    \n    \n      2\n      B\n      79\n    \n    \n      3\n      B\n      46\n    \n    \n      4\n      B\n      57\n    \n    \n      ...\n      ...\n      ...\n    \n    \n      95\n      B\n      69\n    \n    \n      96\n      A\n      71\n    \n    \n      97\n      A\n      93\n    \n    \n      98\n      A\n      63\n    \n    \n      99\n      A\n      82\n    \n  \n\n100 rows × 2 columns\n\n\n\n(9) type==’A’의 평균score를 구하는 코드를 작성하라.\n(풀이)\n\nm = df.query(\"type=='A'\").score.mean()\nm\n\n68.4\n\n\n(10) type==’A’의 평균score보다 같거나 큰 값을 가지는 행을 출력하라.\n(풀이)\n\n# \n# 아래모두 정답으로 인정 (문제설명이 불충분) \n# df.query(\"type=='A' and score >= @m\") \n# df.query(\"score >= @m\")"
  },
  {
    "objectID": "posts/04_Appendix/2022-06-14-final.html#가위-바위-보-하나빼기-150점",
    "href": "posts/04_Appendix/2022-06-14-final.html#가위-바위-보-하나빼기-150점",
    "title": "참고자료: 2022-06-final",
    "section": "2. 가위, 바위, 보 하나빼기 (150점)",
    "text": "2. 가위, 바위, 보 하나빼기 (150점)\n\nclass RPS:\n    def __init__(self,candidate):\n        self.candidate = candidate\n        self.actions = list() \n        self.rewards = list()\n        self.prob = [0.5,0.5]\n\n    def __eq__(self,other): # 연산 == 를 재정의 \n        return self.actions[-1] == other.actions[-1] \n        #note: 둘의 액션이 같으면 무승부 \n    \n    def __gt__(self,other): # 연산 > 를 재정의 \n        pair = self.actions[-1], other.actions[-1]\n        return pair == ('가위','보') or pair == ('바위','가위') or pair == ('보','바위') \n        #note: 가위>보, 바위>가위, 보>가위 \n    \n    def __mul__(self,other):\n        # step1: 각자의 패를 선택 \n        self.choose()\n        other.choose()\n        \n        # step2: 승패 판단 + upate reward\n        if self == other: # 무승부일경우 \n            self.rewards.append(1)\n            other.rewards.append(1)\n        elif self > other: # self의 승리 \n            self.rewards.append(2)\n            other.rewards.append(0)\n        else: # other의 승리 \n            self.rewards.append(0)\n            other.rewards.append(2)\n        \n        # step3: update data\n        self.update_data()\n        other.update_data()\n    \n    def update_data(self):\n        self.data = pd.DataFrame({'actions':self.actions, 'rewards':self.rewards})\n    \n    def _repr_html_(self):\n        html_str = \"\"\"\n        낼 수 있는 패: {} <br/> \n        데이터: <br/>\n        {}\n        \"\"\"        \n        return html_str.format(self.candidate,self.data._repr_html_())\n    \n    def choose(self):\n        self.actions.append(np.random.choice(self.candidate,p=self.prob))\n\n(1) 플레이어A는 (가위,가위) 중 하나를 선택할 수 있고 플레이어B는 (가위,바위) 중 하나를 선택할 수 있다. 각 플레이어는 각 패 중 하나를 랜덤으로 선택하는 액션을 한다고 가정하자. 아래에 해당하는 확률을 시뮬레이션을 이용하여 추정하라.\n\n플레이어A가 승리할 확률:\n플레이어B가 승리할 확률:\n플레이어A와 플레이어B가 비길 확률:\n\nhint: 50% 확률로 b가 승리하고 50% 확률로 비긴다.\n(풀이)\n\nPlayerA = RPS(['가위','가위']) \nPlayerB = RPS(['가위','바위']) \n\nfor _ in range(100):\n    PlayerA * PlayerB\n\n\nprint('플레이어A가 승리할 확률: {}'.format(sum(PlayerA.data.rewards==2)/100))\nprint('플레이어B가 승리할 확률: {}'.format(sum(PlayerA.data.rewards==0)/100))\nprint('플레이어A와 플레이어B가 비길 확률: {}'.format(sum(PlayerA.data.rewards==1)/100))\n\n플레이어A가 승리할 확률: 0.0\n플레이어B가 승리할 확률: 0.57\n플레이어A와 플레이어B가 비길 확률: 0.43\n\n\n(2) 문제 (1)과 같이 아래의 상황을 가정하자.\n\n\n\n\n플레이어A\n플레이어B\n\n\n\n\n각 플레이어가 낼 수 있는 패 (candidate)\n(가위,가위)\n(가위,바위)\n\n\n각 패를 선택할 확률 (prob)\n(0.5,0.5)\n(0.5,0.5)\n\n\n\n각 플레이어는 아래와 같은 규칙으로 가위바위보 결과에 따른 보상점수를 적립한다고 하자. - 승리: 보상점수 2점 적립 - 무승부: 보상점수 1점 적립 - 패배: 보상점수 0점 적립\n100번째 대결까지 시뮬레이션을 시행하고 플레이어B가 가위를 낼 경우 얻은 보상점수의 총합과 바위를 낼 경우 얻은 보상점수의 총합을 각각 구하라. 플레이어B는 가위를 내는것이 유리한가? 바위를 내는것이 유리한가?\nhint: 플레이어B는 바위를 내는 것이 유리하다.\nhint: 플레이어B가 100번중에 49번 가위를 내고 51번 바위를 낸다면 플레이어B가 적립할 보상점수는 각각 아래와 같다. - 가위를 내었을 경우: 49 * 1 = 49점 - 바위를 내었을 경우: 51 * 2 = 102점 - 총 보상점수 = 49점 + 102점 = 151점\n(풀이)\n\nprint('플레이어B가 가위를 낼 경우 얻은 보상점수의 총합: {}'.format(PlayerB.data.query(\" actions=='가위'\").rewards.sum()))\nprint('플레이어B가 바위를 낼 경우 얻은 보상점수의 총합: {}'.format(PlayerB.data.query(\" actions=='바위'\").rewards.sum()))\n\n플레이어B가 가위를 낼 경우 얻은 보상점수의 총합: 43\n플레이어B가 바위를 낼 경우 얻은 보상점수의 총합: 114\n\n\n(3) (2)에서 얻은 데이터를 학습하여 플레이어B가 “가위” 혹은 “바위” 를 선택할 확률을 매시점 조금씩 조정한다고 가정하자. 구체적으로는 현재시점까지 얻은 보상점수의 비율로 확률을 결정한다. 예를들어 플레이어B가 100회의 대결동안 누적한 보상점수의 총합이 아래와 같다고 하자.\n\n가위를 내었을 경우 보상점수 총합 = 50점\n바위를 내었을 경우 보상점수 총합 = 100점\n\n그렇다면 플레이어B는 각각 (50/150,100/150) 의 확률로 (가위,바위) 중 하나를 선택한다. 101번째 대결에 플레이어B가 가위를 내서 비겼다면 이후에는 (51/151,100/151) 의 확률로 (가위,바위) 중 하나를 선택한다. 102번째 대결에 플레이어B가 바위를 내서 이겼다면 이후에는 각각 (51/153,102/153) 의 확률로 (가위,바위) 중 하나를 선택한다. 이러한 상황을 요약하여 표로 정리하면 아래와 같다.\n\n\n\n\n\n\n\n\n\n시점\n플레이어B가 가위를 냈을 경우 얻은 점수 총합\n플레이어B가 바위를 냈을 경우 얻은 점수 총합\nt+1시점에서 플레이어B가 (가위,바위)를 낼 확률\n\n\n\n\nt=100\n50\n100\n(50/150, 100/150)\n\n\nt=101\n51\n100\n(51/151, 100/151)\n\n\nt=102\n51\n102\n(51/153, 102/153)\n\n\n\n이러한 방식으로 500회까지 게임을 진행하며 확률을 수정하였을 경우 501번째 대결에서 플레이어B가 (가위,바위)를 낼 확률은 각각 얼마인가?\nhint: 시간이 지날수록 플레이어B는 (가위,바위)중 바위를 내는 쪽이 유리하다는 것을 알게 될 것이다.\n(풀이)\n\nclass RPS2(RPS):\n    def __init__(self,candidate):\n        # 기존내용\n        self.candidate = candidate\n        self.actions = list() \n        self.rewards = list()\n        self.prob = [0.5,0.5]\n        # 새롭게 정의하는 내용 \n        self.data = dict()\n        self.trainable=False # 학습모드 설정 \n        \n    def update_data(self):\n        a = self.actions[-1]\n        r = self.rewards[-1] \n        self.data[a] = self.data.get(a,0)+r \n        \n    def _repr_html_(self):\n        html_str = \"\"\"\n        낼 수 있는 패: {} <br/> \n        확률: {} <br/>\n        데이터: {} \n        \"\"\"        \n        return html_str.format(self.candidate,self.prob,self.data)\n    \n    def choose(self):\n        if self.trainable:  # if self.trainalbe==True: \n            a1 = self.candidate[0] # action1 \n            a2 = self.candidate[1] # action2 \n            r1 = self.data[a1] # reward from action1 \n            r2 = self.data[a2] # reward from action2 \n            self.prob = [r1/(r1+r2), r2/(r1+r2)] \n        self.actions.append(np.random.choice(self.candidate,p=self.prob))\n\n\nPlayerA=RPS2(['가위','가위'])\nPlayerB=RPS2(['가위','바위'])\n\n\n#\n# 1~100 \nPlayerA.trainable=False \nPlayerB.trainable=False \nfor _ in range(100):\n    PlayerA * PlayerB \n# 100~500     \nPlayerA.trainable=False \nPlayerB.trainable=True\nfor _ in range(400):\n    PlayerA * PlayerB \n\n\nPlayerB\n\n\n        낼 수 있는 패: ['가위', '바위']  \n        확률: [0.1923536439665472, 0.8076463560334528] \n        데이터: {'바위': 678, '가위': 161} \n        \n\n\n\n앞으로 아래와 같은 용어를 사용한다.\n\n(정의) 어떠한 플레이어가 양손 중 하나를 선택하는 확률을 데이터를 바탕으로 매 순간 업데이트 한다면 그 플레이어는 “학습모드 상태이다”고 표현한다.\n(정의) 반대로 어떠한 플레이어가 양손 중 하나를 항상 동일한 확률로 낸다면 그 플레이어는 “학습모드 상태가 아니다”라고 표현한다.\n\n\n(4) 새로운 두명의 플레이어C와 플레이어D를 만들어라. 두 플레이어는 모두 동일하게 (가위,바위) 중 하나를 선택할 수 있다. 두 명의 플레이어는 100번째 대결까지는 두 가지 패중 하나를 랜덤하게 선택하고 101번째 대결부터 500번째 대결까지는 문제(3)의 플레이어B와 같은 방식으로 확률을 업데이트 하여 두 가지 패를 서로 다른 확률로 낸다고 하자. 즉 100번째 대결까지는 두 플레이어가 모두 학습모드 상태가 아니고 101번째부터 500번째 대결까지는 두 플레이어가 모두 학습모드 상태이다. 500번째 대결까지의 학습이 끝났을 경우 플레이어 C와 플레이어D가 각 패를 낼 확률은 각각 얼마인가?\n\n\n\n\n\n\n\n\n\n시점\n플레이어C가 (가위,바위)를 낼 확률\n플레이어D가 (가위,바위)를 낼 확률\n비고\n\n\n\n\nt <= 100\n(1/2, 1/2)\n(1/2, 1/2)\n양쪽 플레이어 모두 학습모드가 아님\n\n\nt <= 500\n대결 데이터를 학습하여 수정한 확률\n대결 데이터를 학습하여 수정한 확률\n양쪽 플레이어 모두 학습모드임\n\n\n\nhint: 시간이 지날수록 두 플레이어 모두 바위를 내는 쪽이 유리하다는 것을 알게 될 것이다.\n(풀이)\n\nPlayerC=RPS2(['가위','바위'])\nPlayerD=RPS2(['가위','바위'])\n\n\n#\n# 1~100 \nPlayerC.trainable=False \nPlayerD.trainable=False \nfor _ in range(100):\n    PlayerC * PlayerD\n# 100~500     \nPlayerC.trainable=True\nPlayerD.trainable=True\nfor _ in range(400):\n    PlayerC * PlayerD \n\n\nPlayerC\n\n\n        낼 수 있는 패: ['가위', '바위']  \n        확률: [0.07692307692307693, 0.9230769230769231] \n        데이터: {'바위': 469, '가위': 39} \n        \n\n\n\nPlayerD\n\n\n        낼 수 있는 패: ['가위', '바위']  \n        확률: [0.07942973523421588, 0.9205702647657841] \n        데이터: {'바위': 453, '가위': 39} \n        \n\n\n\nC,D 모두 바위를 내는게 유리하다는걸 학습함\n\n(5) 새로운 플레이어 E와 F를 생각하자. 플레이어E와 플레이어F는 각각 (가위,바위) 그리고 (가위,보) 중 하나를 선택할 수 있다고 가정하자. 시뮬레이션 대결결과를 이용하여 아래의 확률을 근사적으로 추정하라.\n\n플레이어E가 승리할 확률:\n플레이어F가 승리할 확률:\n플레이어E와 플레이어F가 비길 확률:\n\nhint: 플레이어E가 가위를 낸다면 최소한 지지는 않기 때문에 플레이어E가 좀 더 유리한 패를 가지고 있다. 따라서 플레이어E의 결과가 더 좋을 것이다.\n(풀이)\n\nPlayerE=RPS(['가위','바위'])\nPlayerF=RPS(['가위','보']) \n\nfor _ in range(100):\n    PlayerE * PlayerF\n\nprint('플레이어E가 승리할 확률: {}'.format(sum(PlayerE.data.rewards==2)/100))\nprint('플레이어F가 승리할 확률: {}'.format(sum(PlayerE.data.rewards==0)/100))\nprint('플레이어E와 플레이어F가 비길 확률: {}'.format(sum(PlayerE.data.rewards==1)/100))\n\n플레이어E가 승리할 확률: 0.47\n플레이어F가 승리할 확률: 0.36\n플레이어E와 플레이어F가 비길 확률: 0.17\n\n\n\n두 플레이어 E,F가 모두 랜덤으로 낸다면 (바보처럼 낸다면) 플레이어 E가 더 유리하다.\n\n(6) (5)와 동일한 두 명의 플레이어E, F를 생각하자. 두 플레이어는 100회까지는 랜덤으로 자신의 패를 선택한다. 그리고 101회부터 500회까지는 플레이어F만 데이터로 부터 학습을 하여 수정된 확률을 사용한다. 500번의 대결이 끝나고 플레이어F가 (가위,보)를 선택하는 확률이 어떻게 업데이트 되어있는가?\n\n\n\n\n\n\n\n\n\n시점\n플레이어E가 (가위,바위)를 낼 확률\n플레이어F가 (가위,보)를 낼 확률\n비고\n\n\n\n\nt <= 100\n(1/2, 1/2)\n(1/2, 1/2)\n양쪽 플레이어 모두 학습모드가 아님\n\n\nt <= 500\n(1/2, 1/2)\n데이터를 학습하여 수정한 확률\n플레이어E는 학습모드아님 / 플레이어F는 학습모드\n\n\n\nhint: 플레이어F는 보를 내는 것이 낫다고 생각할 것이다. (가위를 내면 지거나 비기지만 보를 내면 지거나 이긴다.)\n(풀이)\n\nPlayerE=RPS2(['가위','바위'])\nPlayerF=RPS2(['가위','보'])\n\n\n#\n# 1~100 \nPlayerE.trainable=False \nPlayerF.trainable=False \nfor _ in range(100):\n    PlayerE * PlayerF\n# 100~500     \nPlayerE.trainable=False\nPlayerF.trainable=True\nfor _ in range(400):\n    PlayerE * PlayerF\n\n\nPlayerE\n\n\n        낼 수 있는 패: ['가위', '바위']  \n        확률: [0.5, 0.5] \n        데이터: {'바위': 112, '가위': 441} \n        \n\n\n\nPlayerF\n\n\n        낼 수 있는 패: ['가위', '보']  \n        확률: [0.10067114093959731, 0.8993288590604027] \n        데이터: {'보': 402, '가위': 45} \n        \n\n\n\n플레이어F는 보를 내는게 더 유리하다는 것을 학습을 통하여 깨닫는다.\n\n(7) (6)번의 플레이어E와 플레이어F가 500회~1000회까지 추가로 게임을 한다. 이번에는 플레이어E만 데이터로부터 학습한다. 1000회까지 대결을 끝낸 이후 플레이어E가 (가위,바위)를 내는 확률은 어떻게 업데이트 되었는가?\n\n\n\n\n\n\n\n\n\n시점\n플레이어E가 (가위,바위)를 낼 확률\n플레이어F가 (가위,보)를 낼 확률\n비고\n\n\n\n\nt <= 100\n(1/2, 1/2)\n(1/2, 1/2)\n양쪽 플레이어 모두 학습모드가 아님\n\n\nt <= 500\n(1/2, 1/2)\n데이터를 학습하여 수정한 확률\n플레이어E는 학습모드아님 / 플레이어F는 학습모드\n\n\nt <= 1000\n데이터를 학습하여 수정한 확률\nt=500시점에 업데이트된 확률\n플레이어E는 학습모드 / 플레이어F는 학습모드아님\n\n\n\nhint: 플레이어F는 보를 내도록 학습되어 있다. 따라서 플레이어E가 바위를 내면 지고 가위를 내면 이길것이다. 따라서 플레이어E는 가위가 유리하다고 생각할 것이다.\n(풀이)\n\n# \n# 500~1000     \nPlayerE.trainable=True\nPlayerF.trainable=False\nfor _ in range(500):\n    PlayerE * PlayerF\n\n\nPlayerE\n\n\n        낼 수 있는 패: ['가위', '바위']  \n        확률: [0.902158273381295, 0.09784172661870504] \n        데이터: {'바위': 136, '가위': 1256} \n        \n\n\n\nPlayerF\n\n\n        낼 수 있는 패: ['가위', '보']  \n        확률: [0.10067114093959731, 0.8993288590604027] \n        데이터: {'보': 528, '가위': 80} \n        \n\n\n\n플레이어E는 가위를 내는게 유리하다는걸 깨닫는다. (플레이어F는 지금 보만 내고 있으니까!)\n\n(8) (7)번의 플레이어E와 플레이어F가 1000회~30000회까지 추가로 게임을 한다. 이번에는 플레이어F만 데이터로부터 학습한다. 30000회까지 대결을 끝낸 이후 플레이어F가 (가위,보)를 내는 확률은 어떻게 업데이트 되었는가?\n\n\n\n\n\n\n\n\n\n시점\n플레이어E가 (가위,바위)를 낼 확률\n플레이어F가 (가위,보)를 낼 확률\n비고\n\n\n\n\nt <= 100\n(1/2, 1/2)\n(1/2, 1/2)\n양쪽 플레이어 모두 학습모드가 아님\n\n\nt <= 500\n(1/2, 1/2)\n데이터를 학습하여 수정한 확률\n플레이어E는 학습모드아님 / 플레이어F는 학습모드\n\n\nt <= 1000\n데이터를 학습하여 수정한 확률\nt=500시점에 업데이트된 확률\n플레이어E는 학습모드 / 플레이어F는 학습모드아님\n\n\nt <= 30000\nt=1000시점에 업데이트된 확률\n데이터를 학습하여 수정한 확률\n플레이어E는 학습모드아님 / 플레이어F는 학습모드\n\n\n\nhint: 플레이어F는 원래 보가 유리하다고 생각하여 보를 자주 내도록 학습되었다. 하지만 플레이어E가 그러한 플레이어F의 성향을 파악하고 가위를 주로 내도록 학습하였다. 플레이어F는 그러한 플레이어E의 성향을 다시 파악하여 이번에는 가위을 자주 내는 것이 유리하다고 생각할 것이다.\n(풀이)\n\n# \n# 1000~30000 \nPlayerE.trainable=False\nPlayerF.trainable=True\nfor _ in range(29000):\n    PlayerE * PlayerF\n\n\nPlayerE\n\n\n        낼 수 있는 패: ['가위', '바위']  \n        확률: [0.902158273381295, 0.09784172661870504] \n        데이터: {'바위': 4468, '가위': 33162} \n        \n\n\n\nPlayerF\n\n\n        낼 수 있는 패: ['가위', '보']  \n        확률: [0.9214985023917028, 0.0785014976082972] \n        데이터: {'보': 1756, '가위': 20614} \n        \n\n\n\n플레이어 E가 가위만 내고 있으므로 플레이어 F는 지지 않기 위해서 가위를 내도록 학습한다.\n\n(9) 플레이어E와 플레이어F의 대결기록을 초기화 한다. 이번에는 플레이어F가 항상 (3/4)의 확률로 가위를 (1/4)의 확률로 보를 낸다고 가정한다. 플레이어E는 100번의 대결까지는 랜덤으로 (가위,바위)중 하나를 내고 101번째 대결부터 1000번째 대결까지는 대결 데이터를 학습하여 수정한 확률을 사용한다고 하자. 1000번째 대결이후에 플레이어E가 (가위,바위)를 내는 확률이 어떻게 업데이트 되어있는가?\n\n\n\n\n\n\n\n\n\n시점\n플레이어E가 (가위,바위)를 낼 확률\n플레이어F가 (가위,보)를 낼 확률\n비고\n\n\n\n\nt <= 100\n(1/2, 1/2)\n(3/4, 1/4)\n양쪽 플레이어 모두 학습모드가 아님\n\n\nt <= 1000\n데이터를 학습하여 수정한 확률\n(3/4, 1/4)\n플레이어E는 학습모드 / 플레이어F는 학습모드 아님\n\n\n\n(풀이)\n\nPlayerE=RPS2(['가위','바위'])\nPlayerF=RPS2(['가위','보'])\n\n\n#\n# 1~100 \nPlayerE.trainable=False \nPlayerF.trainable=False \nPlayerF.prob=[3/4,1/4]\nfor _ in range(100):\n    PlayerE * PlayerF\n# 100~1000     \nPlayerE.trainable=True\nPlayerF.trainable=False\nfor _ in range(900):\n    PlayerE * PlayerF\n\n\nPlayerE\n\n\n        낼 수 있는 패: ['가위', '바위']  \n        확률: [0.363831308077198, 0.636168691922802] \n        데이터: {'바위': 892, '가위': 509} \n        \n\n\n\n플레이어 E는 바위를 내는것이 좀 더 유리하다고 생각한다.\n\n(추가풀이)\n\n# 계속시행한다면?\nPlayerE.trainable=True\nPlayerF.trainable=False\nfor _ in range(10000*100):\n    PlayerE * PlayerF\n\n\nPlayerE\n\n\n        낼 수 있는 패: ['가위', '바위']  \n        확률: [0.1438411969483742, 0.8561588030516258] \n        데이터: {'바위': 1248374, '가위': 209736} \n        \n\n\n\nE가 가위를 냈을경우 보상의 기대값은 \\(1\\times 3/4 + 2 \\times 1/4 = 5/4\\) 이고 바위를 냈을경우 보상의 기대값은 \\(2\\times 3/4 + 0 \\times 1/4 = 6/4\\) 이므로 바위가 더 유리하다. 따라서 점점 바위를 내도록 학습한다.\n\n(10) 플레이어E와 플레이어F의 대결기록을 초기화 한다. 이번에는 플레이어F가 항상 (2/3)의 확률로 가위를 (1/3)의 확률로 보를 낸다고 가정한다. 플레이어E는 100번의 대결까지는 랜덤으로 (가위,바위)중 하나를 내고 101번째 대결부터 1000번째 대결까지는 대결 데이터를 학습하여 수정한 확률을 사용한다고 하자. 1000번째 대결이후에 플레이어E가 (가위,바위)를 내는 확률이 어떻게 업데이트 되어있는가?\n\n\n\n\n\n\n\n\n\n시점\n플레이어E가 (가위,바위)를 낼 확률\n플레이어F가 (가위,보)를 낼 확률\n비고\n\n\n\n\nt <= 100\n(1/2, 1/2)\n(2/3, 1/3)\n양쪽 플레이어 모두 학습모드가 아님\n\n\nt <= 1000\n데이터를 학습하여 수정한 확률\n(2/3, 1/3)\n플레이어E는 학습모드 / 플레이어F는 학습모드 아님\n\n\n\n(풀이)\n\nPlayerE=RPS2(['가위','바위'])\nPlayerF=RPS2(['가위','보'])\n\n\n#\n# 1~100 \nPlayerE.trainable=False \nPlayerF.trainable=False \nPlayerF.prob=[2/3,1/3]\nfor _ in range(100):\n    PlayerE * PlayerF\n# 100~1000     \nPlayerE.trainable=True\nPlayerF.trainable=False\nfor _ in range(900):\n    PlayerE * PlayerF\n\n\nPlayerE\n\n\n        낼 수 있는 패: ['가위', '바위']  \n        확률: [0.5139500734214391, 0.48604992657856094] \n        데이터: {'바위': 664, '가위': 700} \n        \n\n\n\nPlayerF\n\n\n        낼 수 있는 패: ['가위', '보']  \n        확률: [0.6666666666666666, 0.3333333333333333] \n        데이터: {'가위': 344, '보': 292} \n        \n\n\n\nE가 가위를 냈을경우 보상의 기대값은 \\(1\\times 2/3 + 2 \\times 1/3 = 4/3\\) 이고 바위를 냈을 경우 보상의 기대값은 \\(2\\times 2/3 + 0 \\times 1/3 = 4/3\\) 이므로 가위도 바위도 유리하지 않다. 따라서 가위와 바위를 어떠한 확률로 내든 상관없다.\n\n문제2의 추가해설\n(프로그래밍 팁)\n기본적인 구현기능인 RPS클래스를 상속을 이용하여 적절하게 modify하면 문제를 쉽게 풀 수 있습니다. 문항에 따라서 어떤것은 기본 RPS클래스를 쓰는것이 유리하고 어떠한 것은 새로운 클래스를 정의하는 것이 유리할 수 있습니다. 예를들어 2-(1),(2),(5)는 RPS클래스를 그대로 쓰는 것이 유리했으며 나머지는 새로운 클래스인 RPS2를 사용하는것이 문제풀이에 유리했습니다.\n(계산팁)\n추가확률을 계산할 경우 pandas의 dataframe을 이용하는 것보다 RPS2에서 제가 구현한 것 처럼 dict와 같은 내장자료형을 이용하는 것이 훨씬 연산속도가 빠릅니다. 가령 8번문제의 경우 알고리즘에 따라서 연산시간이 오래걸릴 수도 있는데 제가 짠 코드를 기반으로 코랩에서 돌리면 2.4116초 정도로 결과를 얻을 수 있습니다. 연산속도의 차이가 나는 이유는 (1) 기본적으로 판다스는 느리며 (2) RPS의 data에는 모든 자료를 저장는데 RPS2의 data는 각 패를 내었을 경우 보상의 누적만 저장하기 때문입니다. 최근 데이터량의 증가로 인하여 알고리즘의 효율성을 생각해야할 때도 있는데요, 본인이 구현한 코드와 정답코드를 비교해가며 계산시간을 테스트해보는것도 좋은 경험일 것 같습니다. 계산시간을 측정하는 것은 4월18일 강의노트에 사용한 방법을 참고하시면 됩니다.\n(약간의 개념해설)\n이 문제는 제로섬게임의 확장입니다. (양쪽 플레이어의 보상합이 일정하므로 이러한 게임을 constantsum 이라고 부릅니다) 어떤 분은 이 문제를 보고 게임이론을 떠올릴 수 있고 어떤 분은 강화학습을 떠올렸을 것 같습니다.\n문제의 포인트는 상대방의 전략에 따라서 나의 최적전략이 끝없이 달라진다는 점입니다. 문항 (5)-(10)까지의 문제는 이러한 상황을 묘사합니다. 직관적으로는 더 좋은패를 가지고 있는 플레이어E가 유리할 듯 하지만 결국 상대의 패를 보고 전략을 끝없이 수정하면 어떠한 하나의 action도 최적이 될 수 없습니다. 이 문제의 경우 문항 (8)의 시점에서는 둘 다 가위를 내도록 업데이트 되었는데 이를 이용하여 플레이어E가 다시 바위를 낼 수 있고 그 심리를 역이용하여 플레이어F가 다시 보를 낼 수 있고 그 심리를 다시 역이용하여 플레이어E가 다시 가위를 내며 그 심리를 역이용하여 플레이어F는 다시 가위를 낼 수 있어 무한반복이 됩니다. (상대도 바보가 아니거든요.)\n하지만 두 가지 액션을 확률로 선택한다면 문항 (10)의 상황과 같이 상대방이 어떠한 선택을 하더라도 유리한 선택이 존재하지 않는 어떠한 균형점이 존재할 수 있는데 이를 내쉬의 균형이라 합니다. 내쉬의 균형에 따르면 플레이어E는 가위와 바위를 2:1의 비율로 플레이어F는 가위와 보를 2:1로 낼때 서로가 서로의 전략을 바꾸지 않는 균형상태에 도달합니다. 이러한 게임의 셋팅에 대하여 좀 더 관심 있으신 분은 게임이론을 참고하셔서 공부해보시기 바랍니다. (저도 기본적인 내용밖에 모르지만 흥미있는 분야입니다)\n만약 주어진 게임환경에서 플레이어E,F가 (에이전트라고 부릅니다) 전략을 학습하는 과정이 흥미롭게 느껴졌다면 강화학습을 한번 참고해보시기 바랍니다. 강화학습은 알파고를 학습시킨것으로 유명한 알고리즘입니다. 아래영상은 컴퓨터플레이어가 벽돌깨기 게임을 하며 데이터를 쌓고 데이터로 부터 적절한 action을 학습하는 과정을 묘사한 영상입니다.\n\nhttps://www.youtube.com/watch?v=TmPfTpjtdgg\n\n여러분들이 기말고사에서 간단히 만들어본 알고리즘의 발전형입니다. 강화학습에 흥미가 있으시면 방학동안에 공부해보시길 바랍니다. (궁금한 점은 제 메일로 질문하셔도 됩니다, 제가 게임이론은 전공이 아니지만 강화학습은 약간 할줄 알거든요 ㅎㅎ)\n\nAppendix\n- 아래의 클래스를 참고하여 문제1,2을 풀어라. (5월25일 강의노트에 소개된 클래스를 약간 정리한 것)\n\n참고하지 않아도 감점은 없음\n\n\nclass RPS:\n    def __init__(self,candidate):\n        self.candidate = candidate\n        self.actions = list() \n        self.rewards = list()\n        self.prob = [0.5,0.5]\n\n    def __eq__(self,other): # 연산 == 를 재정의 \n        return self.actions[-1] == other.actions[-1] \n        #note: 둘의 액션이 같으면 무승부 \n    \n    def __gt__(self,other): # 연산 > 를 재정의 \n        pair = self.actions[-1], other.actions[-1]\n        return pair == ('가위','보') or pair == ('바위','가위') or pair == ('보','바위') \n        #note: 가위>보, 바위>가위, 보>가위 \n    \n    def __mul__(self,other):\n        # step1: 각자의 패를 선택 \n        self.choose()\n        other.choose()\n        \n        # step2: 승패 판단 + upate reward\n        if self == other: # 무승부일경우 \n            self.rewards.append(1)\n            other.rewards.append(1)\n        elif self > other: # self의 승리 \n            self.rewards.append(2)\n            other.rewards.append(0)\n        else: # other의 승리 \n            self.rewards.append(0)\n            other.rewards.append(2)\n        \n        # step3: update data\n        self.update_data()\n        other.update_data()\n    \n    def update_data(self):\n        self.data = pd.DataFrame({'actions':self.actions, 'rewards':self.rewards})\n    \n    def _repr_html_(self):\n        html_str = \"\"\"\n        낼 수 있는 패: {} <br/> \n        데이터: <br/>\n        {}\n        \"\"\"        \n        return html_str.format(self.candidate,self.data._repr_html_())\n    \n    def choose(self):\n        self.actions.append(np.random.choice(self.candidate,p=self.prob))\n\n- 사용예시\n\na=RPS(['가위','가위'])\nb=RPS(['가위','보'])\n\n\nfor i in range(5):\n    a*b\n\n\na\n\n\n\n        낼 수 있는 패: ['가위', '가위']  \n        데이터: \n        \n\n\n  \n    \n      \n      actions\n      rewards\n    \n  \n  \n    \n      0\n      가위\n      2\n    \n    \n      1\n      가위\n      2\n    \n    \n      2\n      가위\n      1\n    \n    \n      3\n      가위\n      2\n    \n    \n      4\n      가위\n      2\n    \n  \n\n\n        \n\n\n\nb\n\n\n\n        낼 수 있는 패: ['가위', '보']  \n        데이터: \n        \n\n\n  \n    \n      \n      actions\n      rewards\n    \n  \n  \n    \n      0\n      보\n      0\n    \n    \n      1\n      보\n      0\n    \n    \n      2\n      가위\n      1\n    \n    \n      3\n      보\n      0\n    \n    \n      4\n      보\n      0"
  },
  {
    "objectID": "posts/04_Appendix/2021-04-20-mid.html",
    "href": "posts/04_Appendix/2021-04-20-mid.html",
    "title": "참고자료: 2021-04-mid",
    "section": "",
    "text": "클로즈 북, 40분, 문제미리공개X\n\n\n2021년 파이썬 입문 중간고사\n\n1 다음을 읽고 참인것을 모두 골라라. (10점)\n(ㄱ) 딕셔너리는 key와 value가 하나의 쌍으로 되어 {}로 둘러싸여 있다. \n(ㄴ) `abs(-20)`의 실행결과는 `20`이다. \n(ㄷ) `[1]+[2]`의 실행결과는 `[3]` 이다. \n(ㄹ) `(1,)`의 자료형은 tuple이다. \n(ㅁ) 자료형이 `str`이면 각 원소를 쉽게 바꿀 수 있다. \n\n\n2 아래의 실행결과 중 올바른 것은? (35점)\n\n(a)\na=1.0\nb=2\ntype(a+b)\n(ㄱ) int (ㄴ) float (ㄷ) bool  (ㄹ) complex \n(ㅁ) str (ㅂ) list  (ㅅ) tuple (ㅇ) dict \n\n\n(b)\na=1\nb=2\ntype(a==b)\n(ㄱ) int (ㄴ) float (ㄷ) bool  (ㄹ) complex \n(ㅁ) str (ㅂ) list  (ㅅ) tuple (ㅇ) dict \n\n\n(c)\na=1\nb=2\ntype(int(a==b))\n(ㄱ) int (ㄴ) float (ㄷ) bool  (ㄹ) complex \n(ㅁ) str (ㅂ) list  (ㅅ) tuple (ㅇ) dict \n\n\n(d)\ntype([1,2,3])\n(ㄱ) int (ㄴ) float (ㄷ) bool  (ㄹ) complex \n(ㅁ) str (ㅂ) list  (ㅅ) tuple (ㅇ) dict \n\n\n(e)\na=1\ntype(a)\n(ㄱ) int (ㄴ) float (ㄷ) bool  (ㄹ) complex \n(ㅁ) str (ㅂ) list  (ㅅ) tuple (ㅇ) dict \n\n\n(f)\na=(1)\ntype(a)\n(ㄱ) int (ㄴ) float (ㄷ) bool  (ㄹ) complex \n(ㅁ) str (ㅂ) list  (ㅅ) tuple (ㅇ) dict \n\n\n(g)\na=(1,)\ntype(a)\n(ㄱ) int (ㄴ) float (ㄷ) bool  (ㄹ) complex \n(ㅁ) str (ㅂ) list  (ㅅ) tuple (ㅇ) dict \n\n\n\n3 아래의 코드를 잘 읽고 물음에 답하라. (25점)\na=[1,[2],2,[1]]\n\ndef a_add(a,i,j): \n    if type(a[i])==type(a[j]): \n        rtn=a[i]+a[j]\n    else:\n        rtn=a[i],a[j]\n    return rtn\n\n(a) 아래의 출력결과 중 바른 것은?\na[0]==a[2]\n(ㄱ) True (ㄴ) False\n\n\n(b) 아래의 출력결과 중 바른 것은?\ntype(a[0])==type(a[2])\n(ㄱ) True (ㄴ) False\n\n\n(c) 아래의 출력결과를 쓰라.\na_add(a,0,2)\n\n\n(d) 아래의 출력결과를 쓰라.\na_add(a,1,3)\n\n\n(e) 아래의 출력결과중 적절한 것은?\ntype(a_add(a,0,1))\n(ㄱ) int (ㄴ) float (ㄷ) bool  (ㄹ) complex \n(ㅁ) str (ㅂ) list  (ㅅ) tuple (ㅇ) dict \n\n\n\n4 원주율을 출력하는 방법 중 올바른 것을 모두 고르시오 (10점)\n(ㄱ) \nimport math\nmath.pi\n\n(ㄴ) \nimport math\npi \n\n(ㄷ)\nfrom math import pi\npi\n\n(ㄹ)\nfrom math import *\npi\n\n\n5 아래의 에러메시지가 나오는 (잘못된) 코드는? (10점)\n\n(a)\nTypeError: object of type 'float' has no len()\n(ㄱ) len(3.14) \n(ㄴ) len([3.14]) \n(ㄷ) len((3.14,)) \n(ㄹ) len('3.14') \n\n\n(b) (a)의 에러가 나오는 이유에 대하여 설명하라.\n\n\n\n6 아래와 같이 a를 선언하였다고 하자. (ㄱ)-(ㄹ) 중 옳은 설명을 모두 골라라. (10점)\na='guebin'\n(ㄱ) a의 자료형은 str이다. 즉 type(a)의 출력결과는 str이다. \n(ㄴ) len(a)의 실행결과는 1이다. \n(ㄷ) a[0]='G'와 같은 방법으로 첫글자를 대문자로 바꿀 수 있다. \n(ㄹ) a*2의 실행결과는 'guebinguebin'이다. \n\n\n7 [예제코드]의 결과를 관찰하고 물음에 답하라. (10점)\n## 예제코드 ## \na=['G','u','e','b','i','n']\ndel a[0]\na\n## 실행결과 \n['u', 'e', 'b', 'i', 'n']\n\n(a) 아래코드의 출력결과를 쓰라.\na=['G','u','e','b','i','n']\ndel a[0]\ndel a[0]\n\n\n(b) 아래코드의 출력결과 중 올바른 것은?\nb=['1','2','3']\ndel b[-1]\nb\n(ㄱ) ['1', '2']\n(ㄴ) ['2', '3']\n(ㄷ) ['1', '3']\n(ㄹ) 에러메시지로 출력할 수 없음. \n\n\n\n8 다음을 읽고 물음에 답하라. (15점)\n\n(a) 아래는 .append에 대한 사용예시이다.\n### .append 예시 \na=[1,2]\na.append(3)\nprint(a)\n### 실행결과 \n[1, 2, 3]\n\n\n위의 코드를 참고하여 아래의 실행결과를 쓰라.\nx=[]\nfor i in [0,1,2,3,4,5]:\n    x.append(2**i)\nx\n\n\n(b) 리스트 컴프리헨션을 사용하여 (a)와 동일한 출력결과를 얻는 코드를 작성하라.\n\n\n(c) 리스트 컴프리헨션을 사용하여 아래의 출력결과를 얻는 코드를 작성하라.\n['X1','X2','X3','Y1','Y2','Y3']\n\n\n\n9 a,b에 저장된 두 값을 교환하고 싶다고 하자. 아래의 ???에 알맞은 내용을 적으시오. (10점)\na=10\nb=20\n???\na,b\n## 실행결과\n(20, 10)\n\n\n10 아래의 코드에 대한 출력결과를 쓰라. (10점)\nidlist=[('guebin', '202112345','M','Korea'), \n        ('iu', '202154321','F','Korea'), \n        ('hodong', '201812321','M','Korea')]\nfor name, _, _, _ in idlist: \n    print(name)        \n\n\n11 리스트를 활용하여 아래와 같은 배열을 만들었다고 하자. (15점)\na=[[11,12,13], \n   [21,22,23], \n   [31,32,33]]\n\n(a) 아래코드의 시행결과를 쓰라.\na[0][1]+a[1][2]\n\n\n(b) 아래코드의 시행결과를 쓰라.\na[0]+a[1]\n\n\n(c) 아래코드의 시행결과를 쓰라.\nimport numpy as np\na=np.array(a)\na[0]+a[1]\n\n\n\n12 아래와 같은 연립방정식을 만족하는 해 \\((w,x,y,z)\\)를 푸는 코드를 작성하라. (20점)\n\\(\\begin{cases} x+y+z=3 \\\\ w+y+z=3 \\\\ w+x+z=3 \\\\ w+x+y=3 \\end{cases}\\)\n\n\n13 아래와 같은 행렬을 numpy를 이용하여 선언했다고 하자. (15점)\nimport numpy as np\nA=np.array([[11,12,13,14,15],\n            [21,22,23,24,25],\n            [31,32,33,34,35]])\n\n(a) 다음 코드의 실행결과로 적절한 것은?\nA[1]\n(ㄱ) array([11, 12, 13, 14, 15])\n(ㄴ) array([21, 22, 23, 24, 25])\n(ㄷ) array([11, 21, 31])\n(ㄹ) array([12, 22, 32])\n\n\n(b) 다음 코드의 실행결과로 적절한 것은?\nA[1,:]\n(ㄱ) array([11, 12, 13, 14, 15])\n(ㄴ) array([21, 22, 23, 24, 25])\n(ㄷ) array([11, 21, 31])\n(ㄹ) array([12, 22, 32])\n\n\n(c) 다음 코드의 실행결과로 적절한 것은?\nA[np.ix_([0,1],[0,1])]\n(ㄱ)\narray([[11, 12],\n       [21, 22]]) \n(ㄴ) \narray([[11, 21],\n       [12, 22]]) \n(ㄷ) \narray([11, 12, 21, 22]) \n\n(ㄹ) \narray([12, 22, 11, 12])\n\n\n\n14 적당한 과정을 통하여 아래와 같은 데이터를 얻었다고 가정하자. (20점)\nimport pandas as pd\n#...적당한과정...\ndf\n\n#hide_input\nfrom IPython.display import HTML\nHTML('<table border=\"1\" class=\"dataframe\">\\n  <thead>\\n    <tr style=\"text-align: right;\">\\n      <th></th>\\n      <th>age</th>\\n      <th>toeic</th>\\n      <th>gpa</th>\\n    </tr>\\n  </thead>\\n  <tbody>\\n    <tr>\\n      <th>새로이</th>\\n      <td>30.0</td>\\n      <td>600</td>\\n      <td>4.0</td>\\n    </tr>\\n    <tr>\\n      <th>이서</th>\\n      <td>20.0</td>\\n      <td>950</td>\\n      <td>4.2</td>\\n    </tr>\\n    <tr>\\n      <th>일권</th>\\n      <td>28.0</td>\\n      <td>450</td>\\n      <td>2.3</td>\\n    </tr>\\n    <tr>\\n      <th>현이</th>\\n      <td>28.0</td>\\n      <td>650</td>\\n      <td>3.8</td>\\n    </tr>\\n  </tbody>\\n</table>')\n\n\n\n  \n    \n      \n      age\n      toeic\n      gpa\n    \n  \n  \n    \n      새로이\n      30.0\n      600\n      4.0\n    \n    \n      이서\n      20.0\n      950\n      4.2\n    \n    \n      일권\n      28.0\n      450\n      2.3\n    \n    \n      현이\n      28.0\n      650\n      3.8\n    \n  \n\n\n\n\n(a) 첫 두열(age,toeic)에 접근하는 코드를 써라.\n\n\n(b) 토익점수가 800이상인 사람을 불러오는 코드를 써라.\n\n\n(c) 세번째 열(gpa)에 접근하는 코드 중 적절한 것을 모두 골라라.\n(ㄱ) \ndf.loc['gpa']\n(ㄴ) \ndf.iloc[:,2]\n(ㄷ) \ndf.iloc[:,-1]\n(ㄹ) \ndf.iloc[2]\n\n\n(d) 나이가 23보다 많고 토익점수가 635이하 학점이 3.0 이상인 사람을 불러오는 코드를 작성하라.\n\n\n\n15 아래를 보고 적절한 설명을 한 사람을 모두 고르라. (10점)\nimport vec\nvec?\nType:        module\nString form: <module 'vec' from '/home/cgb2/vec/__init__.py'>\nFile:        ~/vec/__init__.py\nDocstring:   이 패키지는 현재 길이가 2,3인 벡터의 연산만 지원하지만 추후 업데이트하여 더욱 발전할 예정\n(로이) import vec이 실행되는 것을 보니 (1) 사용자가 vec이라는 패키지를 설치했거나 (2) 사용자가 현재 작업중인 폴더에 vec.py파일을 만들었거나 (3) 사용자가 현재 작업중인 폴더 아래 vec이라는 폴더가 존재하는 경우등 중 하나라고 볼 수 있겠군.\n(이서) 네, 그런데 vec?의 실행 결과중 File:을 확인해 보니 사용자가 작업중인 폴더아래 vec이라는 폴더가 있는것으로 판단됩니다.\n(일권) 이서가 말한대로 File:을 확인해보니 사용자가 vec폴더에 __init__.py도 만들어 놓았음을 알수 있군. __init__.py는 import vec을 수행하면 암시적으로 실행된다고 했었지?\n(현이) 그렇지, 그런데 사실 파일 이름이 꼭 __init__.py이어야 하는것은 아니야.\n(수아) vec?의 실행결과 Docstring:이 있는것으로 보아 __init__.py상단에 아래와 같은 내용이 있음을 유추할 수 있어.\n'''\n이 패키지는 현재 길이가 2,3인 벡터의 연산만 지원하지만 추후 업데이트하여 더욱 발전할 예정\n'''"
  },
  {
    "objectID": "posts/04_Appendix/2022-05-03-mid.html",
    "href": "posts/04_Appendix/2022-05-03-mid.html",
    "title": "참고자료: 2022-04-mid",
    "section": "",
    "text": "오픈 북, 2시간, 문제유형만 공개"
  },
  {
    "objectID": "posts/04_Appendix/2022-05-03-mid.html#imports",
    "href": "posts/04_Appendix/2022-05-03-mid.html#imports",
    "title": "참고자료: 2022-04-mid",
    "section": "0. imports",
    "text": "0. imports\n아래코드를 이용하여 numpy 와 matplotlib을 import하라.\n\nimport numpy as np\nimport matplotlib.pyplot as plt"
  },
  {
    "objectID": "posts/04_Appendix/2022-05-03-mid.html#코드구현-i-40점",
    "href": "posts/04_Appendix/2022-05-03-mid.html#코드구현-i-40점",
    "title": "참고자료: 2022-04-mid",
    "section": "1. 코드구현 I (40점)",
    "text": "1. 코드구현 I (40점)\n주의: 문제에 조건이 있는 경우 조건을 준수할 것\n(1) a의 type을 bool로 바꾸어라.\n\na=1.0\n\n\nnote: 출제의도: 자료형의 변환\n\n(풀이)\n\nbool(a)\n\nTrue\n\n\n\n(2)-(6)\n아래의 문자열을 고려하자.\n\ntest_arr = 'ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@mylaptop.local'\n\n(2) 위 문자열에서 짝수번째 원소를 출력하는 코드를 작성하라.\n\nnote: 출제의도: 인덱싱, 스트라이딩\n\n(풀이)\n\ntest_arr[1::2]\n\n's-s AA3zCy2AABwAQAlUkHfY7bmINTKTo/WSGlnflDY7d4Ze1J4WjhFvQMxEEfhlXQkPpw0d3b7OJMylXC+A3XiBxXnhpAscL86jNQddFSV/XtFoosc19530w8eFbzUlQKrX8yNvYb6wP0wr/nZA4ZnP8ZmMuyDc8Zi8+wr+namkns10QalqSbNRiwfMQ=shcnmlpo.oa'\n\n\n(3) 위 문자열에서 마지막 10개의 원소를 출력하는 코드를 작성하라.\n\nnote: 출제의도: -인덱싱\n\n(풀이)\n\ntest_arr[-10:]\n\n'ptop.local'\n\n\n(4) 위 문자열을 뒤집은 문자열을 구하는 코드를 작성하라. 즉 아래를 출력하는 코드를 작성하라.\n'lacol.potpalym@nocahcs ==Q7M+frw9iFRrNxbsSVqMlTarQ10d1os2njkImtaKn1+3r3wg+b8li/Z68Ec2DryauLMVmPZ98IPTnPZO4WA+ZmnE/trewr0bP/wv6ybNYjvDNpyX88XrrpKJQjlFUuz1bmFIe/86wW0V3+5x9Q1McnsAoJoaF3tAX7/KVlSvFMdsdwQANsjR6V8qLicMsZAHpXhKn1XixqBtiRXF3oAH+RCFXWlByTM/JdOk7vbP3adc0gwSppPbkVQ5XFl9h4fVELElx7MzQivrFUhbj9WJ4HJ81we5Zy4Idh7WYTDHlzfan+lPGUSDWB/mojT9KGTLNpITmrbS71YHfrHDkpUOlkAEQAAAwIBAAAAE2cy1CazN3BAAAA asr-hss'\n\nnote: 출제의도: -1 스트라이딩\n\n(풀이)\n\ntest_arr[::-1]\n\n'lacol.potpalym@nocahcs ==Q7M+frw9iFRrNxbsSVqMlTarQ10d1os2njkImtaKn1+3r3wg+b8li/Z68Ec2DryauLMVmPZ98IPTnPZO4WA+ZmnE/trewr0bP/wv6ybNYjvDNpyX88XrrpKJQjlFUuz1bmFIe/86wW0V3+5x9Q1McnsAoJoaF3tAX7/KVlSvFMdsdwQANsjR6V8qLicMsZAHpXhKn1XixqBtiRXF3oAH+RCFXWlByTM/JdOk7vbP3adc0gwSppPbkVQ5XFl9h4fVELElx7MzQivrFUhbj9WJ4HJ81we5Zy4Idh7WYTDHlzfan+lPGUSDWB/mojT9KGTLNpITmrbS71YHfrHDkpUOlkAEQAAAwIBAAAAE2cy1CazN3BAAAA asr-hss'\n\n\n(5) 위 문자열에서 대문자의 수를 count하라.\nhint .isupper() 메소드를 이용할 것.\n\n'a'.isupper()\n\nFalse\n\n\n\n'A'.isupper()\n\nTrue\n\n\n\n'='.isupper()\n\nFalse\n\n\n\n'@'.isupper()\n\nFalse\n\n\n\nnote: 출제의도: 리스트컴프리헨션, bool자료형의 sum\n\n(풀이)\n\nsum([s.isupper() for s in test_arr])\n\n155\n\n\n(6) 위 문자열에서 사용된 문자 및 특수문자의 종류는 모두 몇가지 인가?\nnote1: 문자열 ‘AAB @ab’ 에서 사용된 문자는 ‘A’, ‘B’, ’ ‘,’@‘, ’a’, ‘b’ 이므로 모두 6종류의 문자 및 특수문자가 사용되었다.\nnote2: ’ ‘,’+‘,’-‘,’.’, ‘/’, ‘=’, ‘@’, ‘1’, ‘a’, ‘A’ 등을 모두 다른 문자로 취급한다.\n\nnote: 출제의도: set 자료형의 이해\n\n(풀이)\n\nlen(set(test_arr))\n\n69\n\n\n\n(7) 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 생성하라\n['a',\n 'aa',\n 'aaa',\n 'aaaa',\n 'aaaaa',\n 'aaaaaa',\n 'aaaaaaa',\n 'aaaaaaaa',\n 'aaaaaaaaa',\n 'aaaaaaaaaa'] <- a가 10개있음 \n\nnote: 출제의도: 문자열의 * 연산, 리스트컴프리헨션\n\n(풀이)\n\n['a'*i for i in range(1,11)]\n\n['a',\n 'aa',\n 'aaa',\n 'aaaa',\n 'aaaaa',\n 'aaaaaa',\n 'aaaaaaa',\n 'aaaaaaaa',\n 'aaaaaaaaa',\n 'aaaaaaaaaa']\n\n\n(8) 길이가 1인 튜플을 만들어 자신의 학번을 저장하라. 길이가 1인 튜플을 만들어 자신의 영문이름을 저장하라. 두 튜플을 + 연산자로 합쳐아래와 같은 출력결과를 얻어라.\n(202143052,'guebin')\n\nnote: 출제의도: 튜플의 + 연산, 길이가 1인 튜플\n\n(풀이)\n\na=(202143052,)\nb=('guebin',)\na+b\n\n(202143052, 'guebin')\n\n\n(9) 아래와 같은 list가 있다고 하자.\ntest_lst = [['g',1],['u',5],['e',2],['b',8],['i',2],['n',9]]\ntest_lst와 리스트컴프리헨션을 이용하여 아래를 출력하는 코드를 구현하라.\n['g', 'uuuuu', 'ee', 'bbbbbbbb', 'ii', 'nnnnnnnnn']\n\nnote: 출제의도: 스트링의 + 연산, 리스트 컴프리헨션\n\n(풀이)\n\ntest_lst = [['g',1],['u',5],['e',2],['b',8],['i',2],['n',9]]\n[i*j for i,j in test_lst]\n\n['g', 'uuuuu', 'ee', 'bbbbbbbb', 'ii', 'nnnnnnnnn']\n\n\n(10) 다음은 학생들의 출석,레포트,중간고사,기말고사 점수를 입력으로 하여 학점을 계산하는 함수이다.\n\ndef grade(attendance, report, mid, final): \n    if attendance<70: \n        credit = 'F' \n    else: \n        total_score = attendance * 0.1 + report * 0.2 + mid * 0.3 + final * 0.4 \n        if total_score > 80: \n            credit = 'A+' \n        else:\n            credit = 'B0' \n    return credit \n\n아래는 학생들의 학번, 출석점수, 레포트, 중간고사, 기말고사 점수가 입력된 리스트이다.\n\ndata = [['202212345', [100,95,25,90]],\n        ['202212346', [60,90,95,95]],\n        ['202212347', [50,90,45,35]],\n        ['202212348', [90,90,50,75]],\n        ['202212349', [100,95,85,85]],\n        ['202212350', [90,90,100,95]],\n        ['202212351', [100,95,100,95]],\n        ['202212352', [95,85,80,60]],\n        ['202212353', [100,90,60,55]],\n        ['202212354', [100,85,70,95]],\n        ['202212355', [100,95,40,100]]]\n\n아래의 ???를 적절하게 완성하여 학생들의 학점을 계산하는 코드를 완성하라.\n[grade(???) for _, scores in data] \n\nnote: 출제의도: dummy variable _, 언패킹연산자 *, for문과 튜플언패킹, 리스트컴프리헨션\n\n(풀이)\n\n[grade(*scores) for _, scores in data] \n\n['B0', 'F', 'F', 'B0', 'A+', 'A+', 'A+', 'B0', 'B0', 'A+', 'A+']\n\n\n(11) 길이가 0인 문자열을 선언하라.\n\nnote: 출제의도: 길이가 0인 문자열\n\n(풀이)\n\nlen('')\n\n0\n\n\n\n(12)-(15)\n(12) dir(plt)와 dir(np)를 각각 실행하라. 실행결과를 각각 a,b로 저장하라. a,b의 type은 무엇인가?\n\nnote: 출제의도: type사용법\n\n(풀이)\n\na=dir(plt)\nb=dir(np)\ntype(a),type(b)\n\n(list, list)\n\n\n(13) a의 원소와 b의 원소의 수를 각각 구하라.\n\nnote: 출제의도: len의 사용법 및 응용\n\n(풀이)\n\nlen(a),len(b)\n\n(254, 611)\n\n\n(14) a와 b의 공통원소의 수를 구하라.\n\nnote: 출제의도: set에서 & 연산자 이용\n\n(풀이)\n\nlen(set(a)&set(b))\n\n9\n\n\n(15) a와 b의 원소를 합친 리스트를 만들어라. (공통원소는 중복하여 합치지 않는다)\n\nnote: 출제의도: set에서 | 연산자 이용\n\n(풀이)\n\nlst = list(set(a)|set(b))\n\n\n(16)-(18) 아래와 같은 dictionary가 있다.\n\ntest_dic = {'202212345': {'att':100,'rep':95,'mid':25,'fin':90},\n            '202212346': {'att':60,'rep':90,'mid':95,'fin':95},\n            '202212347': {'att':50,'rep':90,'mid':45,'fin':35},\n            '202212348': {'att':90,'rep':90,'mid':50,'fin':75},\n            '202212349': {'att':100,'rep':95,'mid':85,'fin':85},\n            '202212350': {'att':90,'rep':90,'mid':100,'fin':95},\n            '202212351': {'att':100,'rep':95,'mid':100,'fin':95},\n            '202212352': {'att':95,'rep':85,'mid':80,'fin':60},\n            '202212353': {'att':100,'rep':90,'mid':60,'fin':55},\n            '202212354': {'att':100,'rep':85,'mid':70,'fin':95},\n            '202212355': {'att':100,'rep':95,'mid':40,'fin':100}}\n\n여기에서 202212345등은 학번을, att는 출석점수, rep는 레포트점수, mid는 중간고사점수, fin은 기말고사 점수를 의미한다.\n(16) get 메소드를 이용하여 202212353에 해당하는 학생의 성적을 아래와 같이 리턴하라.\n{'att': 100, 'rep': 90, 'mid': 60, 'fin': 55}\n\nnote: 출제의도: 딕셔너리에서 get 메소드 이용\n\n(풀이)\n\ntest_dic.get('202212353')\n\n{'att': 100, 'rep': 90, 'mid': 60, 'fin': 55}\n\n\n(17) 202212354의 레포트 점수를 리턴하라.\n\nnote: 출제의도: 딕셔너리에서 key를 이용한 원소추출\n\n(풀이)\n\ntest_dic['202212354']['rep']\n\n85\n\n\n(18) 학생들의 학번을 리턴하는 코드를 작성하라.\n\nnote: 출제의도: 딕셔너리와 for문\n\n(풀이)\n\n[k for k in test_dic]\n\n['202212345',\n '202212346',\n '202212347',\n '202212348',\n '202212349',\n '202212350',\n '202212351',\n '202212352',\n '202212353',\n '202212354',\n '202212355']\n\n\n\n(19) shape이 ()인 numpy이 array를 만들어라. (즉 차원이 0인 np.array를 만들어라)\n\nnote: 출제의도: 0차원인 numpy array\n\n(풀이)\n\nnp.array(3).shape\n\n()\n\n\n(20) shape이 (2,2)인 단위행렬을 만들어라.\n\nnote: 출제의도: 넘파이에서의 배열선언\n\n(풀이)\n\nnp.array([[1,0],[0,1]])\n\narray([[1, 0],\n       [0, 1]])\n\n\n(21) a의 모든 원소에 1을 더하는 코드를 작성하라.\na=[1,3,2,5,-3,3,8,2,3,1] \n\nnote: 출제의도: 브로드캐스팅\n\n(풀이)\n\nnp.array([1,3,2,5,-3,3,8,2,3,1])+1\n\narray([ 2,  4,  3,  6, -2,  4,  9,  3,  4,  2])\n\n\n(22) 아래와 같은 수열을 생성하라.\n1,3,6,10,15,21,28,36,45, ... , 378, 406, 435\nhint: 이 수열에서 \\(a_n-a_{n-1}=n, ~n\\geq 2\\) 이다. 즉 3-1=2, 6-3=3, 10-6=4, …\n\nnote: 출제의도: np.arange, cumsum\n\n(풀이)\n\n435-406\n\n29\n\n\n\nnp.arange(1,30).cumsum()\n\narray([  1,   3,   6,  10,  15,  21,  28,  36,  45,  55,  66,  78,  91,\n       105, 120, 136, 153, 171, 190, 210, 231, 253, 276, 300, 325, 351,\n       378, 406, 435])\n\n\n(23) 아래와 같은 수열을 생생성하라.\n0,1,2,3,4,5,...,99 \n위의 수열에서 1,4,7,10,13,… 번째의 원소를 뽑아라. (첫번째 원소는 0이다)\n\nnote: 출제의도: np.arange, 스트라이딩\n\n(풀이)\n\nnp.arange(100)[::3]\n\narray([ 0,  3,  6,  9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48,\n       51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99])\n\n\n(24) numpy를 이용하여 아래의 역행렬을 구하라. \\[\\begin{bmatrix}\n1&  0 \\\\\n0&  3\n\\end{bmatrix}\\]\n\nnote: 출제의도: np.linalg.inv\n\n(풀이)\n\nnp.linalg.inv(np.array([[1,0],[0,3]]))\n\narray([[1.        , 0.        ],\n       [0.        , 0.33333333]])\n\n\n\n(25)-(30)\na,b가 아래와 같이 주어졌다고 하자.\n\na=[1]*10 \nb=[2]*10 \n\n(25) a,b와 np.concatenate를 이용하여 아래와 같은 배열을 만들어라.\narray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])\n\nnote: 출제의도: np.concatenate\n\n(풀이)\n\nnp.concatenate([a,b])\n\narray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])\n\n\n(26) a,b와 np.concatenate를 이용하여 아래와 같은 배열을 만들어라.\narray([[1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2]])\n\nnote: 출제의도: np.concatenate\n\n(풀이)\n\nnp.concatenate([np.array(a).reshape(-1,1),np.array(b).reshape(-1,1)])\n\narray([[1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2]])\n\n\n(27) a,b와 np.concatenate를 이용하여 아래와 같은 배열을 만들어라.\narray([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n       [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]\n\nnote: 출제의도: np.concatenate\n\n(풀이)\n\nnp.concatenate([np.array(a).reshape(1,-1),np.array(b).reshape(1,-1)])\n\narray([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n       [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]])\n\n\n(28) a,b와 np.concatenate를 이용하여 아래와 같은 배열을 만들어라.\narray([[1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2]])\n\nnote: 출제의도: np.concatenate\n\n(풀이)\n\nnp.concatenate([np.array(a).reshape(-1,1),np.array(b).reshape(-1,1)],axis=1)\n\narray([[1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2]])\n\n\n(29) a,b와 np.stack을 이용하여 아래와 같은 배열을 만들어라.\narray([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n       [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]\n(풀이)\n\nnp.stack([a,b])\n\narray([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n       [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]])\n\n\n\nnote: 출제의도: np.stack\n\n(30) a,b와 np.stack을 이용하여 아래와 같은 배열을 만들어라.\narray([[1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2]])\n\nnote: 출제의도: np.stack\n\n(풀이)\n\nnp.stack([a,b],axis=1)\n\narray([[1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2]])\n\n\n(31) 아래와 같은 배열이 있다고 하자.\n\na=np.array([1,2,3,4,5])\nb=np.array([3,2,1,1,2])\n\nnumpy의 @ 연산자를 이용하여 \\(\\sum_{i=1}^{5}a_ib_i\\)를 계산하라.\n\nnote: 출제의도: @연산자의 계산 및 해석\n\n(풀이)\n\na@b\n\n24\n\n\n(32) 아래와 같은 배열을 생성하라.\nx=np.random.randn(100)\nnumpy의 @연산자를 이용하여 \\(\\sum_{i=1}^{100}x_i^2\\)을 계산하라.\n\nnote: 출제의도: @연산자의 계산 및 해석\n\n(풀이)\n\nx=np.random.randn(100)\nx@x\n\n69.28009497479688\n\n\n(33) 아래와 같은 배열을 생성하라.\na=np.array([1/100]*100)\nx=np.random.randn(100)\nnumpy의 @연산자를 이용하여 \\(\\frac{1}{n}\\sum_{i=1}^{n}x_i\\)를 계산하라.\n\nnote: 출제의도: @연산자의 계산 및 해석\n\n(풀이)\n\na=np.array([1/100]*100)\nx=np.random.randn(100)\na@x\n\n-0.010052841585430794\n\n\n(34) 표준정규분포에서 100개의 난수를 생성하라.\n\nnote: 출제의도: 표준정규분포 생성\n\n(풀이)\n\nnp.random.randn(100)\n\narray([ 1.85418429,  1.74095494,  1.84238756,  0.11833414,  0.50517813,\n       -0.69557289, -1.72748266, -0.26601374,  0.57719853,  0.18027158,\n       -0.42542364,  0.85536403, -0.58893928,  0.55397097, -1.5535881 ,\n       -0.88229423, -0.71875421, -0.43570715, -0.30980515, -0.36179948,\n       -0.17548155,  1.44052988, -0.59466028,  0.17292887, -0.59491904,\n       -1.9695988 ,  0.11928747,  1.28964429,  0.53823904, -1.18030647,\n       -0.20558282, -1.08160482,  0.83372329,  0.28800561,  0.15599112,\n       -1.03586037, -1.06770958, -2.71210449,  0.58241292,  0.69235475,\n        1.37391505, -0.0326631 , -0.12266586, -0.20292358, -0.27657851,\n        0.56420234,  0.40045754, -0.63219726,  0.40820948, -0.612829  ,\n       -1.28695191,  0.46508036,  0.2463253 , -0.27429529, -0.65675501,\n       -1.01875321, -0.69944952, -0.31570476,  0.3646879 , -1.1631018 ,\n       -1.20414629, -0.90456531,  0.89434359, -0.29053615,  1.16408738,\n        0.71108284, -0.52138787,  1.07033411,  1.72342412,  0.90605155,\n       -0.28896114, -1.89628331, -1.71603025,  1.21529517,  0.23833153,\n       -0.52176073, -0.49144623, -0.75427022,  0.10468367,  0.36750664,\n        0.24346823,  0.20762347,  1.08915492,  1.89502878,  1.91479936,\n       -0.4241885 , -1.05989046,  0.96622936,  0.40962212, -2.16589513,\n        0.45357349, -1.23802044,  0.39859558,  0.02910548,  1.44679724,\n        1.16285902, -0.1593022 , -2.14983146,  0.42739322, -0.94301164])\n\n\n(35) 아래와 동일한 코드를 np.random.rand()로 구현하라.\nnp.random.uniform(low=2,high=4,size=(5,)) \n\nnote: 출제의도: np.random.rand, np.random.uniform\n\n(풀이)\n\nnp.random.rand(5)*2+2\n\narray([3.62616239, 2.4038075 , 2.64420359, 2.80481305, 2.2678642 ])\n\n\n(36) 아래와 같은 배열을 선언하라.\na=np.random.randn(100) \nnp.where를 이용하여 a의 모든 음수를 0으로 바꾸는 코드를 작성하라.\n\nnote: 출제의도: np.where 을 이용한 마스킹\n\n(풀이)\n\na=np.random.randn(100)\nnp.where(a<0,0,a)\n\narray([0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00,\n       0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 6.23392366e-01,\n       0.00000000e+00, 1.08600932e+00, 3.67178107e-01, 0.00000000e+00,\n       2.20251453e-01, 0.00000000e+00, 0.00000000e+00, 3.89764950e-02,\n       6.86794220e-01, 6.89479404e-01, 1.26211471e+00, 0.00000000e+00,\n       4.23611162e-01, 8.19460987e-01, 3.14530150e-01, 0.00000000e+00,\n       0.00000000e+00, 0.00000000e+00, 1.30354361e+00, 0.00000000e+00,\n       0.00000000e+00, 4.40581127e-01, 0.00000000e+00, 0.00000000e+00,\n       7.86386724e-01, 1.92151119e-02, 0.00000000e+00, 0.00000000e+00,\n       0.00000000e+00, 3.23260088e-01, 0.00000000e+00, 7.13352290e-01,\n       0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 7.01771469e-01,\n       0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 1.01926360e+00,\n       0.00000000e+00, 1.00933996e+00, 0.00000000e+00, 5.55528483e-01,\n       5.99763436e-01, 0.00000000e+00, 1.35136571e-01, 1.35928670e-02,\n       9.35722269e-01, 0.00000000e+00, 8.64547752e-01, 0.00000000e+00,\n       0.00000000e+00, 0.00000000e+00, 1.68682634e+00, 0.00000000e+00,\n       1.07091321e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00,\n       8.27772542e-01, 0.00000000e+00, 7.65702396e-01, 0.00000000e+00,\n       0.00000000e+00, 3.29389519e-01, 0.00000000e+00, 2.51416616e-01,\n       0.00000000e+00, 8.17591580e-01, 0.00000000e+00, 1.09930438e-01,\n       8.71101099e-04, 2.17063699e-01, 2.06385934e-01, 0.00000000e+00,\n       0.00000000e+00, 0.00000000e+00, 3.19516814e-01, 5.92549379e-02,\n       1.92857588e+00, 1.39519785e+00, 3.77551912e-01, 0.00000000e+00,\n       0.00000000e+00, 0.00000000e+00, 5.16744013e-01, 0.00000000e+00,\n       1.87178822e+00, 1.75448718e+00, 3.40204387e-01, 7.69851631e-01])\n\n\n(37) 아래와 같은 배열을 선언하라.\na=np.random.randn(100) \n위 배열의 최소값이 위치한 index를 return하라.\n\nnote: 출제의도: np.where\n\n(풀이)\n\na=np.random.randn(100)\nnp.where(a==np.min(a))\n\n(array([92]),)\n\n\n(38) 아래와 같은 배열을 선언하라.\n\na=np.arange(12).reshape(3,4)\na\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n\n차원의 수를 유지하면서 1열을 추출하는 코드를 작성하라. 즉 결과가 아래와 같이 나오도록 하라.\narray([[0],\n       [4],\n       [8]])\n\nnote: 출제의도: 차원을 유지하는 인덱싱\n\n(풀이)\n\na[:,[0]]\n\narray([[0],\n       [4],\n       [8]])\n\n\n(39)-(40)\n(39) 자신의 학번으로 random seed 를 설정하라. [20,25)의 범위에서 100개의 정수를 랜덤으로 생성해 (10,10) shape의 배열을 만들어라.\n\nnote: 출제의도: np.random.randint\n\n(풀이)\n\nnp.random.seed(43052)\na=np.random.randint(low=20,high=25,size=(10,10))\n\n(40) 39의 결과에서 20,21,22 는 각각 몇개씩 있는가?\n\nnote: 출제의도: bool형의 sum\n\n(풀이)\n\nnp.sum(a==20),np.sum(a==21),np.sum(a==22)\n\n(17, 20, 19)"
  },
  {
    "objectID": "posts/04_Appendix/2022-05-03-mid.html#코드구현-ii-50점",
    "href": "posts/04_Appendix/2022-05-03-mid.html#코드구현-ii-50점",
    "title": "참고자료: 2022-04-mid",
    "section": "2. 코드구현 II (50점)",
    "text": "2. 코드구현 II (50점)\n\n(1)-(6) 아래의 코드를 실해하여 test_dic를 생성하라.\n\nnp.random.seed(43052)\natt = np.random.choice(np.arange(10,21)*5,200)\nrep = np.random.choice(np.arange(5,21)*5,200)\nmid = np.random.choice(np.arange(0,21)*5,200)\nfin = np.random.choice(np.arange(0,21)*5,200)\nkey = ['202212'+str(s) for s in np.random.choice(np.arange(300,501),200,replace=False)]\ntest_dic = {key[i] : {'att':att[i], 'rep':rep[i], 'mid':mid[i], 'fin':fin[i]} for i in range(200)}\ndel(att);del(rep);del(mid);del(fin);del(key)\n\n여기에서 202212345등은 학번을, att는 출석점수, rep는 레포트점수, mid는 중간고사점수, fin은 기말고사 점수를 의미한다.\n(1) test_dic에서 출석점수가 70이상(70>=)인 학생들의 학번을 출력하는 코드를 작성하라.\n\nnote: 출제의도: if문이 포함된 리스트컴프리헨션, for문과 딕셔너리\n\n(풀이)\n\nids= [k for k in test_dic if test_dic[k]['att']>=70]\n\n(2) test_dic에서 출석점수가 70미만(<70)인 학생들의 수를 구하라.\n\nnote: 출제의도: if문이 포함된 리스트컴프리헨션, for문과 딕셔너리\n\n(풀이)\n\nlen([k for k in test_dic if test_dic[k]['att']<70])\n\n70\n\n\n\nsum([test_dic[k]['att']<70 for k in test_dic])\n\n70\n\n\n(3) test_dic에서 출석점수가 70이상(70>=)인 학생들의 중간고사 점수의 평균을 계산하라.\n\nnote: 출제의도: if문이 포함된 리스트컴프리헨션, for문과 딕셔너리\n\n(풀이)\n\nnp.mean([test_dic[k]['mid'] for k in test_dic if test_dic[k]['att']>=70])\n\n57.15384615384615\n\n\n(4) test_dic에서 중간고사 점수를 출력하는 코드를 작성하라.\n\nnote: 출제의도: 리스트컴프리헨션, for문과 딕셔너리\n\n(풀이)\n\nmid=[test_dic[k]['mid'] for k in test_dic]\n\n(5) test_dic에서 중간고사 점수의 표준편차와 레포트점수의 표준편차를 구하여라. 어떤것이 더 큰가?\n\nnote: 출제의도: 리스트컴프리헨션, for문과 딕셔너리, np.std\n\n(풀이)\n\nnp.std([test_dic[k]['mid'] for k in test_dic]),np.std([test_dic[k]['rep'] for k in test_dic])\n\n(29.88243631299162, 22.626533097229014)\n\n\n(6) test_dic에서 중간고사 점수가 가장 높은 사람의 학번을 출력하라.\n주의: att,rep,mid,fin,key를 실행하여 소멸시키지 않고 그대로 이용하거나 np.random.choice()를 이용하여 재생성한 뒤 계산할 경우 0점 처리함. - 예를들면 (5)의 경우 np.std(mid), np.std(rep) 와 같은 식으로 구현하면 0점 처리함.\n\nnote: 출제의도: 리스트컴프리헨션, for문과 딕셔너리\n\n(풀이)\n\n[k for k in test_dic if test_dic[k]['mid']==max(mid)]\n\n['202212326',\n '202212463',\n '202212383',\n '202212341',\n '202212417',\n '202212401',\n '202212405',\n '202212369',\n '202212403',\n '202212407',\n '202212315']\n\n\n\n(7) 성공확률이 0.45인 시행이 있다고 하자. 이 시행을 100번의 시행하였을 경우 73번 이상 성공할 확률은 얼마인가? 시뮬레이션을 이용하여 근사계산하라.\n\nnote: 출제의도: np.random.binomial, bool형의 합\n\n(풀이)\n\nsum(np.random.binomial(n=100,p=0.45,size=(1000,)) >= 73)\n\n0\n\n\n(8) 성공확률이 0.45인 시행이 있다고 하자. 이 시행을 100번 시행하였을 경우 10번이하로 실패하거나 90번이상 성공할 확률은 얼마인가? 시뮬레이션을 이용하여 근사계산하라.\n\nnote: 출제의도: np.random.binomial, bool형의 합\n\n(풀이)\n\na=np.random.binomial(n=100,p=0.45,size=(1000,))\nsum((a>=90) | (a<=10))\n\n0\n\n\n\nsum(a>=90) + sum(a<=10) # 이것도 좋은 풀이\n\n0\n\n\n(9) 아래와 같은 행렬을 선언하자.\n\nA=np.arange(2*1).reshape(2,1)\nB=np.arange(2*2).reshape(2,2)\nC=np.arange(2*3).reshape(2,3)\nD=np.arange(3*3).reshape(3,3)\nE=np.arange(3*2).reshape(3,2)\nF=np.arange(3*1).reshape(3,1)\n\n아래의 블락매트릭스를 만들어라.\n\\(\\begin{bmatrix} a_{11} & b_{11} & b_{12} & c_{11} & c_{12} & c_{13} \\\\ a_{21} & b_{21} & b_{22} & c_{21} & c_{22} & c_{23} \\\\ d_{11} & d_{12} & d_{13} & e_{11} & e_{12} & f_{11} \\\\ d_{21} & d_{22} & d_{23} & e_{21} & e_{22} & f_{21} \\\\ d_{31} & d_{32} & d_{33} & e_{31} & e_{32} & f_{31} \\end{bmatrix}\\)\n여기에서 \\(a_{ij}\\)는 매트릭스 \\({\\bf A}\\)의 원소이다.\n\nnote: 출제의도: np.concatenate\n\n(풀이)\n\ntop = np.concatenate([A,B,C],axis=1)\nbottom = np.concatenate([D,E,F],axis=1)\nnp.concatenate([top,bottom],axis=0)\n\narray([[0, 0, 1, 0, 1, 2],\n       [1, 2, 3, 3, 4, 5],\n       [0, 1, 2, 0, 1, 0],\n       [3, 4, 5, 2, 3, 1],\n       [6, 7, 8, 4, 5, 2]])\n\n\n(10) 표준정규분포에 10000개의 난수를 아래와 같이 생성하라.\n\nx=np.random.randn(10000)\ny=np.random.randn(10000)\n\n\\((i,j)\\) 번째 원소가 \\((x_i-y_j)^2\\)인 (10000,10000) 매트릭스를 만들어라.\n\nnote: 출제의도: 브로드캐스팅\n\n(풀이)\n\n(x.reshape(10000,1) - y.reshape(1,10000))**2\n\narray([[9.94471594e-01, 1.59617444e+00, 4.89939117e-01, ...,\n        5.85763251e-02, 8.71831383e-01, 4.48231705e-02],\n       [3.82650425e-01, 7.82788668e-01, 1.16338019e+00, ...,\n        3.85231232e-01, 1.72229831e+00, 3.48524169e-01],\n       [2.19381916e-03, 4.81046770e-02, 3.04162913e+00, ...,\n        1.65404203e+00, 3.91165053e+00, 1.57699602e+00],\n       ...,\n       [4.06902110e-02, 4.15352671e-03, 3.60584637e+00, ...,\n        2.07641061e+00, 4.54827803e+00, 1.98997559e+00],\n       [6.35135252e-01, 1.13022358e+00, 8.10422594e-01, ...,\n        1.95632560e-01, 1.28594998e+00, 1.69738287e-01],\n       [3.93009857e+00, 5.05626325e+00, 8.13727798e-02, ...,\n        5.52331661e-01, 2.65189382e-03, 5.98303522e-01]])\n\n\n\n(11)-(16)\n아래와 같은 매트릭스를 생성하라.\n\nnp.random.seed(43052)\na=np.random.randn(10000).reshape(100,100)\na\n\narray([[ 0.38342049,  1.0841745 ,  1.14277825, ..., -0.18506968,\n         1.05538764,  1.18701443],\n       [-0.25027283, -1.58045215,  0.1124153 , ...,  1.0321894 ,\n         0.40438012, -0.13491595],\n       [-0.76763724, -0.64294232, -0.24782396, ..., -0.01530161,\n         0.89125897, -0.82683395],\n       ...,\n       [-1.41379028,  0.79611333, -0.71011837, ..., -0.9860352 ,\n         1.30755244,  2.18677233],\n       [ 1.33968105, -0.78457449, -0.10405858, ..., -0.71110186,\n         0.99841286,  2.34371635],\n       [-0.66422032, -0.07550233,  0.7405869 , ...,  1.03232398,\n        -0.18988252, -0.03578389]])\n\n\n(11) 각 행의 합을 구하라. 즉 1행의 합, 2행의 합, … 100행의 합을 계산하라. - 1행의합 = 0.38342049 + 1.0841745 + … + 1.18701443\n\nnote: 출제의도: np.sum with axis\n\n(풀이)\n\na.sum(axis=1)\n\narray([-8.13607922e+00,  9.87120533e+00, -1.41434956e+01, -2.21705363e+00,\n       -1.45535236e+01, -9.15821678e+00, -2.59866360e+00, -1.54562385e+01,\n       -1.42005088e+00, -3.51523111e+00,  9.70487578e+00, -1.26229105e+01,\n        1.66837113e+00,  2.43015457e+00,  2.72990184e+00, -7.99486429e+00,\n       -8.38305954e-01, -8.45002020e+00, -1.03610098e+00,  2.07251861e+01,\n        1.11461478e+01,  7.62144075e+00, -7.93734585e+00,  1.82844319e+01,\n       -2.63562392e+00, -8.97916930e+00, -1.88986183e+00, -9.32477049e+00,\n       -6.69074565e+00, -1.42463143e+01,  6.45540510e-01,  1.80911488e+00,\n        2.40997157e+00,  1.63367254e+01,  7.63990677e+00,  8.13524813e+00,\n        3.97159000e+00, -1.10542949e+00,  4.37564512e-01,  2.87299971e+00,\n       -4.01016768e+00,  5.71115215e+00, -4.64132698e+00, -9.13987753e+00,\n       -6.78326000e+00,  3.36308150e+00, -5.13704342e+00, -5.09782466e+00,\n        6.54192465e-03,  7.19722660e+00, -4.64674820e+00, -9.24124039e+00,\n        6.73530841e+00,  1.12168921e+00,  1.61615988e+00,  1.37602200e+01,\n        6.67289840e-01, -2.09578108e+00, -2.81826564e-01, -8.52416541e+00,\n       -7.21970047e+00,  2.27146777e+01, -1.40341974e+01,  1.69263136e+01,\n       -1.80568372e+01,  6.52142336e+00, -1.73092812e+01, -1.34999285e+01,\n       -7.85539317e+00, -4.74940393e-01, -2.75765037e+01,  8.74991555e+00,\n       -9.77324158e+00,  1.42854121e+01, -1.10130356e+00, -1.39206483e-01,\n       -1.54638921e+01,  1.36814794e+00,  8.41394160e+00, -2.42153833e+00,\n       -2.57155344e+01, -6.72423820e+00, -9.49366257e-01,  3.79493472e+00,\n       -6.23508582e+00,  7.75657189e+00,  9.69403620e+00,  1.46847519e+01,\n        7.36500792e+00, -2.54755192e+01,  1.22792449e+01, -1.02497847e+01,\n        1.30452028e+01,  3.92943038e+00, -3.27227585e+00, -1.06633071e+01,\n       -1.56942302e+01,  8.01451222e+00,  2.81546938e+00,  5.56774384e+00])\n\n\n(12) (11)의 결과로 나온 배열의 표준편차를 구하라.\n\nnote: 출제의도: np.sum with axis, np.std\n\n(풀이)\n\na.sum(axis=1).std()\n\n9.98012658863081\n\n\n(13) 각 열의 평균을 구하라. 즉 1열의 평균, 2열의 평균, … , 100열의 평균을 계산하라.\n\nnote: 출제의도: np.sum with axis\n\n(풀이)\n\na.sum(axis=0)\n\narray([ 5.05543481e-01, -8.11250975e-01, -7.27142023e-01,  9.64876493e+00,\n        5.64186324e+00, -2.22728206e+00,  1.32808256e-02, -9.60905067e+00,\n        9.42144096e+00, -1.21946518e+01, -2.21878576e+00, -3.77018716e+00,\n        2.35739166e-01, -1.13202128e+01, -9.00374437e+00, -3.09372275e+00,\n       -2.18029121e+00,  7.04210003e+00, -4.12563112e+00,  2.58233488e+00,\n        1.16578817e+01, -1.59430241e+01, -1.53668953e+00,  9.21879710e+00,\n       -1.11346500e+01, -1.20131585e+01,  5.94139652e+00, -3.27022797e+00,\n       -1.46466366e+00, -1.78386785e+00, -1.06650333e+01, -9.04542721e+00,\n       -8.52586244e+00,  5.52166280e+00,  1.94115122e+01,  4.64389603e+00,\n        5.13636914e+00,  1.11424801e+01, -4.18629084e+00,  9.23822150e+00,\n       -2.00433998e+00, -5.73784795e+00, -8.79928414e+00, -3.01766235e+00,\n        6.47256326e+00,  3.14419234e+00, -1.16146865e+01, -1.04800787e+01,\n        3.17924308e+00,  5.51687322e+00,  1.04913214e+01, -2.79741703e-01,\n        2.56767141e+01, -1.35620430e+01, -9.59492302e+00,  1.23241275e+01,\n       -5.26436946e-01, -3.14823093e+00, -4.00286104e+00, -1.48618576e+01,\n        4.85988487e+00, -1.37972086e+01, -1.04715966e+01, -7.13893940e+00,\n        4.35483376e+00, -2.10610822e+01, -1.03231108e+01, -1.62132451e+01,\n        2.85187037e+01, -8.25697744e+00,  4.33723229e+00,  1.32763889e+00,\n       -1.61919484e+01, -5.07924036e+00,  6.62243327e+00, -9.72863991e+00,\n        2.71962223e+01, -5.97710822e+00,  1.54580795e+01, -5.46739064e+00,\n       -1.08611574e+01, -1.56520706e+01, -1.40476317e+01,  1.06067589e+01,\n       -3.46141736e+00, -6.07673046e+00,  5.33471760e-01,  8.10276105e+00,\n       -1.31994569e+01, -1.00936968e+00,  6.13944222e+00, -9.72765699e+00,\n        1.61342793e+01,  1.02634369e+01, -5.03038014e+00, -7.50604837e+00,\n        2.63992605e+00,  6.98470602e+00, -1.89567885e+01,  7.91910813e+00])\n\n\n(14) (13)의 결과로 나온 배열의 표준편차를 구하라.\n\nnote: 출제의도: np.sum with axis, np.std\n\n(풀이)\n\na.sum(axis=0).std()\n\n9.944992000065781\n\n\n(15) a의 원소중 a>0 을 만족하는 원소의 평균을 구하여라.\n\nnote: 출제의도: bool을 이용한 인덱싱\n\n(풀이)\n\na[a>0].mean()\n\n0.7879030416692301\n\n\n(16) a의 원소중 a>3을 만족하는 원소의 수를 count하라.\n\nnote: 출제의도: bool의 sum\n\n(풀이)\n\nnp.sum(a>3)\n\n17\n\n\n\n(17)-(18)\n아래와 같은 배열 a를 고려하자.\n\nnp.random.seed(43052)\na=np.random.binomial(1,0.2,size=(10000,))\na\n\narray([1, 0, 1, ..., 1, 1, 0])\n\n\n(17) 0에서 1로 바뀌는 부분을 count하라.\n\nnote: 출제의도: np.diff 응용\n\n(풀이)\n\nnp.sum(np.diff(a)==1)\n\n1617\n\n\n(18) 1에서 0으로 바뀌는 부분을 count하라.\n[예시] 아래의 배열에서 0에서 1로 부분은 모두 세 군데이고, 1에서 0으로 바뀌는 부분은 모두 두 군데 이다.\n0 0 0 1 0 1 0 0 0 1 1 1 \n\nnote: 출제의도: np.diff 응용\n\n(풀이)\n\nnp.sum(np.diff(a)==-1)\n\n1618\n\n\n\n(19)-(25)\n(19) \\(i=1,2,\\dots,1000\\)에 대하여 아래를 각각 구하라.\n\\[x_i= \\cos(t_i)+\\cos(3t_i)+\\cos(5t_i)\\]\n\\[y_i= \\sin(t_i)+\\sin(4t_i)\\]\n여기에서 \\(t_i=\\frac{2\\pi i }{1000}\\) 이다.\n\nnote: 출제의도: numpy를 이용한 수식표현\n\n(풀이)\n\ni=np.arange(1,1001)\nt=i*2*np.pi/1000\nx=np.cos(t)+np.cos(3*t)+np.cos(5*t) \ny=np.sin(t)+np.sin(4*t) \n\n(20) \\((x_i,y_i)\\)를 그려라.\n\nnote: 출제의도: plt.plot\n\n(풀이)\n\nplt.plot(x,y)\n\n\n\n\n(21) 아래와 같은 변환을 통하여 \\((w_i,z_i)\\)를 얻어라.\n\\[w_i= \\frac{1}{\\sqrt{2}}x_i - \\frac{1}{\\sqrt{2}}y_i\\]\n\\[z_i= \\frac{1}{\\sqrt{2}}x_i + \\frac{1}{\\sqrt{2}}y_i\\]\n\\((w_i,z_i)\\)를 시각화 하라.\n\nnote: 출제의도: numpy를 이용한 연산, plt.plot\n\n(풀이)\n\nw = 1/np.sqrt(2)*x -  1/np.sqrt(2)*y\nz = 1/np.sqrt(2)*x +  1/np.sqrt(2)*y\nplt.plot(w,z)\n\n\n\n\n(22) 아래와 같은 매트릭스를 만들어라.\n\\[{\\bf A}=\\begin{bmatrix}\nx_1 & y_1 \\\\\nx_2 & y_2 \\\\\n\\dots & \\dots \\\\\nx_n & y_n\n\\end{bmatrix}\\]\n\nnote: 출제의도: np.stack\n\n(풀이)\n\nA=np.stack([x,y]).T\nA\n\narray([[ 2.99930917e+00,  3.14132394e-02],\n       [ 2.99723725e+00,  6.28103581e-02],\n       [ 2.99378587e+00,  9.41752452e-02],\n       ...,\n       [ 2.99723725e+00, -6.28103581e-02],\n       [ 2.99930917e+00, -3.14132394e-02],\n       [ 3.00000000e+00, -1.22464680e-15]])\n\n\n\nA=np.stack([x,y],axis=1)\nA\n\narray([[ 2.99930917e+00,  3.14132394e-02],\n       [ 2.99723725e+00,  6.28103581e-02],\n       [ 2.99378587e+00,  9.41752452e-02],\n       ...,\n       [ 2.99723725e+00, -6.28103581e-02],\n       [ 2.99930917e+00, -3.14132394e-02],\n       [ 3.00000000e+00, -1.22464680e-15]])\n\n\n(23) \\({\\bf A} {\\bf B}\\)의 첫번째 열과 두번째 열을 시각화한 결과가 \\((w_i,z_i)\\)과 동일하도록 적당한 (2,2) 매트릭스 \\({\\bf B}\\)를 만들어라.\n\nnote: 출제의도: 행렬의 수식표현, 행렬의 곱\n\n(풀이)\n\nB= np.array([[1/np.sqrt(2), 1/np.sqrt(2)],[-1/np.sqrt(2), 1/np.sqrt(2)]])\n#B= np.array([[1, 1],[-1, 1]])/np.sqrt(2)\nplt.plot(A@B[:,0],A@B[:,1])\n\n\n\n\n(24) \\({\\bf A}{\\bf B}^2\\)의 첫번째 열과 두번째 열을 시각화 하라.\n\nnote: 출제의도: 행렬의 곱\n\n(풀이)\n\nplt.plot((A@B@B)[:,0],(A@B@B)[:,1])\n\n\n\n\n(25) \\(n=3,4,5,6,\\dots\\) 에 대하여 \\({\\bf A}{\\bf B}^n\\)을 반복적으로 그려보라. \\((x_i,y_i)\\)의 시각화 결과와 동일한 가장 작은 \\(n\\)은 얼마인가? \\((w_i,z_i)\\)의 시각화 결과와 동일한 가장 작은 \\(n\\)은 얼마인가?\n\nnote: 출제의도: 회전변환의 유추, 역행렬의 개념응용\n\n(풀이)\n\nplt.plot((A@B@B@B)[:,0],(A@B@B@B)[:,1]) ## n=3\n\n\n\n\n\nplt.plot((A@B@B@B@B)[:,0],(A@B@B@B@B)[:,1]) ## n=4\n\n\n\n\n\n(B@B)@(B@B)@(B@B)@(B@B)\n\narray([[1., 0.],\n       [0., 1.]])\n\n\n\n(B@B)@(B@B)@(B@B)@(B@B)@B\n\narray([[ 0.70710678,  0.70710678],\n       [-0.70710678,  0.70710678]])\n\n\n\n답: \\((x_i,y_i)\\)의 시각화 결과와 동일한 가장 작은 \\(n=8\\) 이고 \\((w_i,z_i)\\)의 시각화 결과와 동일한 가장 작은 \\(n=9\\) 이다."
  },
  {
    "objectID": "posts/04_Appendix/2022-05-03-mid.html#다음을-잘-읽고-물음에-답하라.-10점",
    "href": "posts/04_Appendix/2022-05-03-mid.html#다음을-잘-읽고-물음에-답하라.-10점",
    "title": "참고자료: 2022-04-mid",
    "section": "3. 다음을 잘 읽고 물음에 답하라. (10점)",
    "text": "3. 다음을 잘 읽고 물음에 답하라. (10점)\n(1) 아래는 python을 설치하는 방법을 소개한 url 이다. 직접 url에 들어가서 설치하는 방법을 읽어보고 곤이, 철용, 아귀, 짝귀 중 옳은말을 한 사람을 모두 골라라.\n\nhttps://www.pythonlikeyoumeanit.com/Module1_GettingStartedWithPython/Installing_Python.html\n\n(곤이) 해당 방법은 아나콘다를 이용하여 파이썬을 설치하는 방법이다.\n(철용) 그래서 이 방법으로는 가상환경을 만들 수 없겠군.\n(아귀) 위 url에 제시된 방법으로 설치하면 주피터가 자동설치 된다.\n(짝귀) 따라서 위의 방법으로 설치하면 IDE는 주피터만 사용할 수 있다.\n\nnote: 출제의도: 아나콘다를 이용한 설치\n\n(2) 곤이는 1부터 10까지의 합을 구하는 코드를 작성하기 위하여 아래와 같이 mysum.py 파일을 만들었다.\n## mysum.py\ntotal = 0 \nfor i in range(1,11): \n    total = total + i\nprint(total)\n곤이의 컴퓨터는 윈도우이며 아니콘다를 이용해 파이썬을 설치하였다고 가정한다. 다음중 옳은 설명을 한 사람을 모두 고르라.\n(곤이) mysum.py를 실행하기 위해서는 anaconda prompt 에서 mysum.py가 위치한 폴더로 이동한 뒤 %run mysum.py 를 실행하면 된다.\n(철용) anaconda prompt 에서 mysum.py가 위치한 폴더로 이동한 뒤 ipython을 실행하고 %run mysum.py을 실행해도 된다.\n(아귀) 철용의 방법에서 %run mysum.py 대신에 !python mysum.py를 쳐도 동작한다.\n(짝귀) 하지만 다른 가상환경을 만들 경우 철용과 아귀의 방법으로 실행할 수 없다는 단점이 있다.\n\nnote: 출제의도: *.py 의 사용방법"
  },
  {
    "objectID": "posts/04_Appendix/2021-06-09-final.html",
    "href": "posts/04_Appendix/2021-06-09-final.html",
    "title": "참고자료: 2021-06-final",
    "section": "",
    "text": "오픈 북, 2시간, 문제미리공개\n\n\n2021년 파이썬입문 기말고사 (풀이포함)\n\n# 1. (20점)\nN사에서 게임유저들에게 여름방학 기념이벤트로 진명왕의 집판검이라는 이름의 아이템을 선물했다고 하자. 진명왕의 집판검은 총 5회에 걸쳐서 강화(upgrade)될 수 있데 강화의 성공확률은 10%라고 하자. 강화가 5번성공하면 더 이상 강화가 진행되지 않는다고 하자. (따라서 더 이상 강화시도를 하지 않아도 무방하다) 아래는 이 아이템에 강화를 진행하였을때 각 강화상태를 설명한 예시이다.\n\n\n\n시도횟수\n강화성공여부\n강화상태\n비고\n\n\n\n\n1\n강화실패\n+0 \\(\\to\\) +0\n강화실패로 인하여 강화상태 변화없음\n\n\n2\n강화성공\n+0 \\(\\to\\) +1\n강화성공으로 인한 강화상태 변화\n\n\n3\n강화실패\n+1 \\(\\to\\) +1\n강화실패로 인하여 강화상태 변화없음\n\n\n4\n강화성공\n+1 \\(\\to\\) +2\n강화성공으로 인한 강화상태 변화\n\n\n5\n강화성공\n+2 \\(\\to\\) +3\n강화성공으로 인한 강화상태 변화\n\n\n6\n강화성공\n+3 \\(\\to\\) +4\n강화성공으로 인한 강화상태 변화\n\n\n7\n강화실패\n+4 \\(\\to\\) +4\n강화실패로 인하여 강화상태 변화없음\n\n\n8\n강화성공\n+4 \\(\\to\\) +5\n모든 강화 성공\n\n\n9\n-\n+5 \\(\\to\\) +5\n더 이상 강화시도 하지 않음\n\n\n10\n\\(\\dots\\)\n\\(\\dots\\)\n\\(\\dots\\)\n\n\n\n강화는 하루에 한 번씩만 시도할 수 있으며 시도가능한 기간은 7월1일부터 8월31일까지로 한정되어 있다고 하자. 따라서 방학동안 유저들은 총 62번 시도를 할 수 있다. 방학이 끝난이후 100명 유저중 대략 몇명정도 +5 강화상태에 있겠는가? 파이썬을 통한 시뮬레이션을 활용하여 추론하라. (단, +5강화에 성공하지 못한 모든 유저는 반드시 하루에 한번 강화를 시도해야 한다고 가정하자.)\n(풀이1)\n\nimport numpy as np\nnp.random.seed(1)\nsum(np.random.binomial(n=62, p=0.1, size=10000)>=5)/10000\n\n0.7514\n\n\n(풀이2)\n\nclass ExecutionSword():\n    def __init__(self,prob):\n        self.nuser=100000\n        self.prob=prob\n        self.attemptresult=None\n        self.upgradestate=pd.DataFrame({'day0':[0]*self.nuser})\n        self.failstate=pd.DataFrame({'day0':[0]*self.nuser})\n        self.ratio=0\n        self.day=0\n    def addday(self):\n        self.day=self.day+1            \n    def attempt(self):\n        self.attemptresult = np.random.binomial(n=1, p=self.prob, size=self.nuser)\n    def update(self):\n        # 강화상태 업데이트\n        self.upgradestate['day%s' % self.day] = np.minimum(5,self.upgradestate['day%s' % (self.day-1)]+self.attemptresult)\n        # 강화실패누적횟수 업데이트 \n        self.failstate['day%s' % self.day]=self.failstate['day%s' % (self.day-1)]+(self.attemptresult==0)*1\n        # 강화상태==5 or 강화상태==0 일 경우 강화실패누적횟수 초기화 \n        self.failstate['day%s' % self.day][self.upgradestate['day%s' % self.day]== 0]=0\n        self.failstate['day%s' % self.day][self.upgradestate['day%s' % self.day]== 5]=0\n    def reset(self):\n        # 실패횟수 = 2 인것을 찾아 index_ 에 저장 -> index_ 에 해당하는 유저의 강화횟수와 실패횟수를 모두 0으로 초기화 \n        index_= self.failstate['day%s' % self.day]==2\n        self.failstate['day%s' % self.day][index_] = 0\n        self.upgradestate['day%s' % self.day][index_] = 0\n    def arrangeprob(self):\n        self.ratio=sum(self.upgradestate['day%s' % self.day]==5) / self.nuser\n        if self.ratio > 0.5:\n            self.prob = 0.9\n\n\n# 1 \nimport pandas as pd\ns1=ExecutionSword(0.1)\nfor i in range(62):\n    s1.addday()\n    s1.attempt()\n    s1.update()\n\n\nsum(s1.upgradestate.day62==5)/s1.nuser\n\n0.75551\n\n\n\n\n# 2. (70점)\n강화성공확률을 40%로 수정한다. 강화에 누적2회 실패하면 강화상태가 초기화 된다고 하자. (따라서 강화실패 누적횟수를 카운트하는 변수가 필요하다) 단, 강화실패 누적횟수는 누적2회 달성시 0으로 초기화 된다. 또한 강화상태가 +0인 경우는 실패하여도 강화실패 누적횟수가 추가되지 않는다.\n\n\n\n시도횟수\n강화성공여부\n강화상태\n강화실패누적\n비고\n\n\n\n\n1\n강화성공\n+0 \\(\\to\\) +1\n0 \\(\\to\\) 0\n-\n\n\n2\n강화성공\n+1 \\(\\to\\) +2\n0 \\(\\to\\) 0\n-\n\n\n3\n강화실패\n+2 \\(\\to\\) +2\n0 \\(\\to\\) 1\n-\n\n\n4\n강화성공\n+2 \\(\\to\\) +3\n1 \\(\\to\\) 1\n-\n\n\n5\n강화실패\n+3 \\(\\to\\) +0\n1 \\(\\to\\) 0\n강화실패로 누적2회로 인한 초기화\n\n\n6\n강화실패\n+0 \\(\\to\\) +0\n0 \\(\\to\\) 0\n강화실패 누적횟수 증가하지 않음\n\n\n7\n강화성공\n+0 \\(\\to\\) +1\n0 \\(\\to\\) 0\n-\n\n\n8\n강화성공\n+1 \\(\\to\\) +2\n0 \\(\\to\\) 0\n-\n\n\n9\n강화성공\n+2 \\(\\to\\) +3\n0 \\(\\to\\) 0\n-\n\n\n10\n강화성공\n+3 \\(\\to\\) +4\n0 \\(\\to\\) 0\n-\n\n\n11\n강화성공\n+4 \\(\\to\\) +5\n0 \\(\\to\\) 0\n모든 강화 성공\n\n\n12\n-\n+5 \\(\\to\\) +5\n0 \\(\\to\\) 0\n더 이상 강화시도 하지 않음\n\n\n13\n\\(\\dots\\)\n\\(\\dots\\)\n\\(\\dots\\)\n\\(\\dots\\)\n\n\n\n(1) 이 경우 62일의 방학뒤에 100명의 유저중 대략 몇명정도 +5 강화상태에 있겠는가? 시뮬레이션을 활용하여 추론하라. (단, +5강화에 성공하지 못한 모든 유저는 반드시 하루에 한번 강화를 시도해야 한다고 가정하자.)\n(2) 31번째 시도 이후 대략 몇명의 유저가 +5 강화상태에 있겠는가?\n\n# 2-1,2 \ns2=ExecutionSword(0.4)\n\n\nfor i in range(62):\n    s2.addday()\n    s2.attempt()\n    s2.update()\n    s2.reset() ## 초기화가 되는 조건이 있으므로 문제1에서 reset함수만 추가하면 된다. \n\n\n# 2-1\nsum(s2.upgradestate.day31==5)/s2.nuser\n\n0.36392\n\n\n\n# 2-2\nsum(s2.upgradestate.day62==5)/s2.nuser\n\n0.61803\n\n\n(3) 100명의 유저중 50명이상의 유저가 +5 강화상태에 도달하는 순간 모든 유저의 강화성공확률을 90%로 증가시킨다고 하자. 62일의 방학뒤에 100명의 유저 중 몇명 정도가 +5 강화상태에 있겠는가?\n\n# 2-3 \ns3=ExecutionSword(0.4)\n\n\nfor i in range(62):\n    s3.addday()\n    s3.attempt()\n    s3.update()\n    s3.reset() ## 초기화가 되는 조건이 있으므로 reset함수 추가\n    s3.arrangeprob() ## 전체유저의 50%가 강화성공하면 강화확률이 조정되는 조건이 있으므로 arragneprob 추가 \n\n\nsum(s3.upgradestate.day62==5)/s3.nuser\n\n0.9993"
  },
  {
    "objectID": "posts/2023-03-06-1wk-1.html",
    "href": "posts/2023-03-06-1wk-1.html",
    "title": "01wk-1: 강의소개",
    "section": "",
    "text": "이 수업을 들어야 하는 이유\n생략\n\n\n\n이 수업을 듣지 말아야 하는 이유\n1. F학점을 많이 준다.\n\n30%까지 F를 줄 수 있음.\nF학점은 태도점수+시험성적을 종합하여 부여함 (태도점수로만 부여하지 않음)\n\n2. 파이썬을 배울 수 있는 다른 대안이 많다.\n\nChatGPT\n패스트캠퍼스\n학원\n각종 캠프\n\n3. cost-effective 하지 않음\n\n열심히 공부해도 시험성적이 안 좋을 수 있음. \\(\\to\\) 학점도 안좋아짐\n왜? (1) 타전공 고수들이 많음 (2) 시험문제가 어려움 (3) 기출문제가 별 의미없음 (4) 적성에 안 맞음\n\n4. 꼭 파이썬을 배워야 할까?\n이거 꼭 들어야 졸업가능? –> 파이썬을 못하면 선택의 폭이 좁아지긴 하지만 졸업불가능한 정도는 아님\n\nhttps://stat.jbnu.ac.kr/stat/6453/subview.do\n\n파이썬 못하면 굶어죽을까? –> 몇몇 진로에서는 파이썬이 필요함. 그런데 다 그런건 아님\n통계학과 졸업생이 갈 수 있는 진로들\n\n의약계열: 전북대병원, XX병원, XX제약, 셀트리온, 삼성바이오\n\n금융계열: 전북은행, XX은행, XX증권, XX화재\n공무원,공기업: 통계청, 9급공무원, 국민연금 등\n기타 대기업: 삼성전자 (인사과)…\n국책연구기관: 에트리, 한국교통연구원 등\n금융공기업: 한국은행, 금융감독원, 한국거래소 등\n제조업: 삼성전자, 하이닉스, LG전자, 현대자동차 등 (스마트팩토리)\n통신사: SKT, KT, LGU\n컨설팅: 베가스, 삼성SDS, LG-CNS 등\n게임회사: 엔씨, 넷마블, 위메이드 등\n인공지능, 빅데이터: 네이버, 카카오, 라인, 쿠팡, 배민(?), SKT, 삼성, LG, …\n순수IT:\n\n\n\n\n수업진행\n\n다음시간부터 개인 노트북 지참\nwifi: 218-5G-1. 218-5G-2\n가급적 영상 올릴 생각… (복습용도)\n질문: 카톡, 이메일, 직접방문, 줌, 등등~"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html",
    "title": "06wk-1: Numpy (1)",
    "section": "",
    "text": "youtube:"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#선언",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#선언",
    "title": "06wk-1: Numpy (1)",
    "section": "선언",
    "text": "선언\n\na=np.array([1,2,3]) # list를 만들고 ndarray화 시킴 \nl=[1,2,3]"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#기본연산-브로드캐스팅",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#기본연산-브로드캐스팅",
    "title": "06wk-1: Numpy (1)",
    "section": "기본연산 브로드캐스팅",
    "text": "기본연산 브로드캐스팅\n\na+1 ## [1,2,3] + 1 = [2,3,4]\n\narray([2, 3, 4])\n\n\n\nl+1\n\nTypeError: can only concatenate list (not \"int\") to list\n\n\n\na*2\n\narray([2, 4, 6])\n\n\n\nl*2\n\n[1, 2, 3, 1, 2, 3]\n\n\n\na/2\n\narray([0.5, 1. , 1.5])\n\n\n\nl/2\n\nTypeError: unsupported operand type(s) for /: 'list' and 'int'\n\n\n\na**2\n\narray([1, 4, 9])\n\n\n\nl**2\n\nTypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'\n\n\n\na%2 # %2 = 2로 나눈 나머지를 리턴 a=[1,2,3] \n\narray([1, 0, 1])\n\n\n\nl%2\n\nTypeError: unsupported operand type(s) for %: 'list' and 'int'"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#기타수학연산지원",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#기타수학연산지원",
    "title": "06wk-1: Numpy (1)",
    "section": "기타수학연산지원",
    "text": "기타수학연산지원\n\nnp.sqrt(a), np.sqrt(l)\n\n(array([1.        , 1.41421356, 1.73205081]),\n array([1.        , 1.41421356, 1.73205081]))\n\n\n\nnp.log(a), np.log(l)\n\n(array([0.        , 0.69314718, 1.09861229]),\n array([0.        , 0.69314718, 1.09861229]))\n\n\n\nnp.exp(a), np.exp(l)\n\n(array([ 2.71828183,  7.3890561 , 20.08553692]),\n array([ 2.71828183,  7.3890561 , 20.08553692]))\n\n\n\nnp.sin(a), np.sin(l)\n\n(array([0.84147098, 0.90929743, 0.14112001]),\n array([0.84147098, 0.90929743, 0.14112001]))"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#인덱싱-1차원",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#인덱싱-1차원",
    "title": "06wk-1: Numpy (1)",
    "section": "인덱싱 1차원",
    "text": "인덱싱 1차원\n- 선언\n\nl=[11,22,33,44,55,66] \na=np.array(l) \n\n- 인덱스로 접근\n\nl[0],l[1],l[2],l[3],l[-2],l[-1]\n\n(11, 22, 33, 44, 55, 66)\n\n\n\na[0],a[1],a[2],a[3],a[-2],a[-1]\n\n(11, 22, 33, 44, 55, 66)\n\n\n- : 이용 (슬라이싱)\n\nl[2:4] # index 2에서 시작, index 4는 포함하지 않음 \n\n[33, 44]\n\n\n\na[2:4] \n\narray([33, 44])\n\n\n- 정수배열에 의한 인덱싱\n\na\n\narray([11, 22, 33, 44, 55, 66])\n\n\n\na[[0,2,4]] # index=0, index=2, index=4 에 해당하는 원소를 뽑고 싶다 \n\narray([11, 33, 55])\n\n\n\nl[[0,2,4]] # 리스트는 불가능 \n\nTypeError: list indices must be integers or slices, not list\n\n\n- 부울값에 의한 인덱싱\n\na\n\narray([11, 22, 33, 44, 55, 66])\n\n\n\na[[True,False,True,False,True,False]] \n\narray([11, 33, 55])\n\n\n응용하면?\n\na < 33 \n\narray([ True,  True, False, False, False, False])\n\n\n\na[a<33]\n\narray([11, 22])\n\n\n리스트는 불가능\n\nl<33 # 여기에서부터 불가능 \n\nTypeError: '<' not supported between instances of 'list' and 'int'\n\n\n\nl[[True,False,True,False,True,False]] # 이것도 불가능 \n\nTypeError: list indices must be integers or slices, not list"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#인덱싱-2차원",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#인덱싱-2차원",
    "title": "06wk-1: Numpy (1)",
    "section": "인덱싱 2차원",
    "text": "인덱싱 2차원\n- 중첩리스트와 2차원 np.array 선언\n\nA = [[1,2,3,4],[-1,-2,-3,-4],[5,6,7,8],[-5,-6,-7,-8]]\nA2 = np.array(A)\n\n\nA2\n\narray([[ 1,  2,  3,  4],\n       [-1, -2, -3, -4],\n       [ 5,  6,  7,  8],\n       [-5, -6, -7, -8]])\n\n\n\nA\n\n[[1, 2, 3, 4], [-1, -2, -3, -4], [5, 6, 7, 8], [-5, -6, -7, -8]]\n\n\n- A의 원소 인덱싱\n\nA[0][0] # (1,1)의 원소 \n\n1\n\n\n\nA[1][2] # (2,3)의 원소 \n\n-3\n\n\n\nA[-1][0] # (4,1)의 원소 \n\n-5\n\n\n- A2의 원소 인덱싱\n\nA2[0][0] # (1,1)의 원소 \n\n1\n\n\n\nA2[1][2] # (2,3)의 원소 \n\n-3\n\n\n\nA2[-1][0] # (4,1)의 원소 \n\n-5\n\n\n- A2에서만 되는 기술 (넘파이에서 제시하는 신기술, R에서는 기본적으로 쓰던것, 이중list는 불가능)\n\nA2[0,0] # (1,1)의 원소 \n\n1\n\n\n\nA2[1,2] # (2,3)의 원소 \n\n-3\n\n\n\nA2[-1,0] # (4,1)의 원소 \n\n-5\n\n\n- 정수배열에 의한 인덱싱 & 슬라이싱!\n\nA2\n\narray([[ 1,  2,  3,  4],\n       [-1, -2, -3, -4],\n       [ 5,  6,  7,  8],\n       [-5, -6, -7, -8]])\n\n\n\nA2[0,0:2] # 1행1열, 1행2열 \n\narray([1, 2])\n\n\n\nA2[0,:] # 1행 \n\narray([1, 2, 3, 4])\n\n\n\nA2[0] # 1행\n\narray([1, 2, 3, 4])\n\n\n\nA2[[0,2],:] # 1행, 3행 \n\narray([[1, 2, 3, 4],\n       [5, 6, 7, 8]])\n\n\n\nA2[[0,2]] # 1행, 3행 \n\narray([[1, 2, 3, 4],\n       [5, 6, 7, 8]])\n\n\n\nA2[:,0] # 1열 \n\narray([ 1, -1,  5, -5])\n\n\n\nA2[:,[0]] # 1열 \n\narray([[ 1],\n       [-1],\n       [ 5],\n       [-5]])\n\n\n\nA2[:,[0,2]] # 1열, 3열\n\narray([[ 1,  3],\n       [-1, -3],\n       [ 5,  7],\n       [-5, -7]])\n\n\n\nA2[0:2,[0,2]] # 1행~2행 //  1열,3열 \n\narray([[ 1,  3],\n       [-1, -3]])"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#차원-배열의-선언",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#차원-배열의-선언",
    "title": "06wk-1: Numpy (1)",
    "section": "1차원 배열의 선언",
    "text": "1차원 배열의 선언\n- 리스트나 튜플을 선언하고 형변환\n\nnp.array((1,2,3)) # 튜플->넘파이어레이 \n\narray([1, 2, 3])\n\n\n\nnp.array([1,2,3]) # 리스트 ->넘파이어레이 \n\narray([1, 2, 3])\n\n\n- range()를 이용해서 선언하고 형변환\n\nnp.array(range(10)) # range(10) -> 넘파이어레이 \n\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\n- np.zeros, np.ones\n\nnp.zeros(3) \n\narray([0., 0., 0.])\n\n\n\nnp.ones(4)\n\narray([1., 1., 1., 1.])\n\n\n- np.linspace\n\nnp.linspace(0,1,12) # 0에서 시작하고 1에서 끝남 (양끝점 모두 포함)\n\narray([0.        , 0.09090909, 0.18181818, 0.27272727, 0.36363636,\n       0.45454545, 0.54545455, 0.63636364, 0.72727273, 0.81818182,\n       0.90909091, 1.        ])\n\n\n\nlen(np.linspace(0,1,12)) # 길이는 12\n\n12\n\n\n- np.arange\n\nnp.arange(5) # np.array(range(5))\n\narray([0, 1, 2, 3, 4])\n\n\n\nnp.arange(1,6) # np.array(range(1,6))\n\narray([1, 2, 3, 4, 5])"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#reshape",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#reshape",
    "title": "06wk-1: Numpy (1)",
    "section": "reshape",
    "text": "reshape\n- reshape: ndarray의 특수한 기능\n\na=np.array([11,22,33,44,55,66])\na ## 길이가 6인 벡터 \n\narray([11, 22, 33, 44, 55, 66])\n\n\n\na.reshape(2,3) ## (2,3) matrix 라고 생각해도 무방 \n\narray([[11, 22, 33],\n       [44, 55, 66]])\n\n\nnote: reshape은 a자체를 변화시키는것은 아님\n\na # a는 그대로 있음 \n\narray([11, 22, 33, 44, 55, 66])\n\n\n\nb= a.reshape(2,3) # a를 reshape한 결과를 b에 저장 \nb\n\narray([[11, 22, 33],\n       [44, 55, 66]])\n\n\n\na # a는 여전히 그대로 있음\n\narray([11, 22, 33, 44, 55, 66])\n\n\n- 다시 b를 a처럼 바꾸고 싶다\n\nb\n\narray([[11, 22, 33],\n       [44, 55, 66]])\n\n\n\nb.reshape(6) # b는 (2,3) matrix , 그런데 이것을 길이가 6인 벡터로 만들고 싶다. \n\narray([11, 22, 33, 44, 55, 66])\n\n\n- reshape with -1\n\na=np.arange(24) # np.array(range(24))\na\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])\n\n\n\na.reshape(2,-1)\n\narray([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11],\n       [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]])\n\n\n\na.reshape(3,-1)\n\narray([[ 0,  1,  2,  3,  4,  5,  6,  7],\n       [ 8,  9, 10, 11, 12, 13, 14, 15],\n       [16, 17, 18, 19, 20, 21, 22, 23]])\n\n\n\na.reshape(4,-1)\n\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 6,  7,  8,  9, 10, 11],\n       [12, 13, 14, 15, 16, 17],\n       [18, 19, 20, 21, 22, 23]])\n\n\n\na.reshape(5,-1)\n\nValueError: cannot reshape array of size 24 into shape (5,newaxis)\n\n\n\na.reshape(6,-1)\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15],\n       [16, 17, 18, 19],\n       [20, 21, 22, 23]])\n\n\n\na.reshape(7,-1)\n\nValueError: cannot reshape array of size 24 into shape (7,newaxis)\n\n\n\na.reshape(8,-1)\n\narray([[ 0,  1,  2],\n       [ 3,  4,  5],\n       [ 6,  7,  8],\n       [ 9, 10, 11],\n       [12, 13, 14],\n       [15, 16, 17],\n       [18, 19, 20],\n       [21, 22, 23]])\n\n\n\na.reshape(12,-1)\n\narray([[ 0,  1],\n       [ 2,  3],\n       [ 4,  5],\n       [ 6,  7],\n       [ 8,  9],\n       [10, 11],\n       [12, 13],\n       [14, 15],\n       [16, 17],\n       [18, 19],\n       [20, 21],\n       [22, 23]])\n\n\n\nb= a.reshape(12,-1)\nb\n\narray([[ 0,  1],\n       [ 2,  3],\n       [ 4,  5],\n       [ 6,  7],\n       [ 8,  9],\n       [10, 11],\n       [12, 13],\n       [14, 15],\n       [16, 17],\n       [18, 19],\n       [20, 21],\n       [22, 23]])\n\n\n\nb.reshape(-1) # b를 다시 길이가 24인 벡터로!\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#차원-배열의-선언-1",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#차원-배열의-선언-1",
    "title": "06wk-1: Numpy (1)",
    "section": "2차원 배열의 선언",
    "text": "2차원 배열의 선언\n\nnp.zeros((3,3))\n\narray([[0., 0., 0.],\n       [0., 0., 0.],\n       [0., 0., 0.]])\n\n\n\nnp.ones((3,3))\n\narray([[1., 1., 1.],\n       [1., 1., 1.],\n       [1., 1., 1.]])\n\n\n\nnp.eye(3)\n\narray([[1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.]])\n\n\n\nnp.diag([1,2,3,-1])\n\narray([[ 1,  0,  0,  0],\n       [ 0,  2,  0,  0],\n       [ 0,  0,  3,  0],\n       [ 0,  0,  0, -1]])"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#랜덤으로-배열-생성",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#랜덤으로-배열-생성",
    "title": "06wk-1: Numpy (1)",
    "section": "랜덤으로 배열 생성",
    "text": "랜덤으로 배열 생성\n\nnp.random.randn(10) # 표쥰정규분포에서 10개를 뽑음 \n\narray([ 0.27184979, -0.4540305 ,  0.24538219, -3.11389327,  1.06478234,\n        0.12051154,  0.01503231, -0.06744028,  2.30710253,  0.78840453])\n\n\n\nnp.random.rand(10) # 0~1사이에서 10개를 뽑음\n\narray([0.67729671, 0.19584606, 0.4564896 , 0.9308976 , 0.49080792,\n       0.03410752, 0.47480477, 0.44519947, 0.20608611, 0.85576604])\n\n\n\nnp.random.randn(4).reshape(2,2) # 표준정규분포에서 4개를 뽑고 (2,2) ndarray로 형태변환 \n\narray([[-0.97378852,  0.5250826 ],\n       [-0.97400213, -0.59600022]])\n\n\n\nnp.random.rand(4).reshape(2,2) # 0~1 4개를 뽑고 (2,2) ndarray로 형태변환 \n\narray([[0.03708309, 0.56122376],\n       [0.80934488, 0.65723348]])"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#행렬관련기능",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#행렬관련기능",
    "title": "06wk-1: Numpy (1)",
    "section": "행렬관련기능",
    "text": "행렬관련기능\n\nA=np.arange(4).reshape(2,2) \nA\n\narray([[0, 1],\n       [2, 3]])\n\n\n\nA.T # .T는 전치행렬을 구해줌 \n\narray([[0, 2],\n       [1, 3]])\n\n\n\nnp.linalg.inv(A) # np.linalg.inv는 역행렬을 구해주는 함수 \n\narray([[-1.5,  0.5],\n       [ 1. ,  0. ]])\n\n\n\nA @ np.linalg.inv(A) # @는 행렬곱을 수행 \n\narray([[1., 0.],\n       [0., 1.]])"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#차원-배열과-연립-1차-방정식",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#차원-배열과-연립-1차-방정식",
    "title": "06wk-1: Numpy (1)",
    "section": "2차원 배열과 연립 1차 방정식",
    "text": "2차원 배열과 연립 1차 방정식\n- 아래의 연립방정식 고려\n\\(\\begin{cases} y+z+w = 3 \\\\ x+z+w = 3 \\\\ x+y+w = 3 \\\\ x+y+z = 3 \\end{cases}\\)\n- 행렬표현?\n\\(\\begin{bmatrix} 0 & 1 & 1 & 1 \\\\ 1 & 0 & 1 & 1 \\\\ 1 & 1 & 0 & 1 \\\\ 1 & 1 & 1 & 0 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ z \\\\ w \\end{bmatrix} = \\begin{bmatrix} 3 \\\\ 3 \\\\ 3 \\\\ 3 \\end{bmatrix}\\)\n- 풀이\n\nA = np.array([[0,1,1,1],[1,0,1,1],[1,1,0,1],[1,1,1,0]])\nA\n\narray([[0, 1, 1, 1],\n       [1, 0, 1, 1],\n       [1, 1, 0, 1],\n       [1, 1, 1, 0]])\n\n\n\nb= np.array([3,3,3,3]).reshape(4,1)\nb\n\narray([[3],\n       [3],\n       [3],\n       [3]])\n\n\n\nnp.linalg.inv(A) @ b \n\narray([[1.],\n       [1.],\n       [1.],\n       [1.]])\n\n\n- 다른풀이\nb를 아래와 같이 만들어도 된다.\n\nb=np.array([3,3,3,3])\nb\n\narray([3, 3, 3, 3])\n\n\n\nb.shape # b.shape은 길이가 1인 튜플로 나온다. \n\n(4,)\n\n\n\nnp.linalg.inv(A) @ b \n\narray([1., 1., 1., 1.])"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#의-유연성",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#의-유연성",
    "title": "06wk-1: Numpy (1)",
    "section": "@의 유연성",
    "text": "@의 유연성\n- 엄밀하게는 아래의 행렬곱이 가능하다. - (2,2) @ (2,1) => (2,1) - (1,2) @ (2,2) => (1,2)\n\nA = np.array([1,2,3,4]).reshape(2,2) \nb = np.array([1,2]).reshape(2,1) \nA@b\n\narray([[ 5],\n       [11]])\n\n\n\nA.shape, b.shape, (A@b).shape\n\n((2, 2), (2, 1), (2, 1))\n\n\n\nA = np.array([1,2,3,4]).reshape(2,2) \nb = np.array([1,2]).reshape(1,2) \nb@A \n\narray([[ 7, 10]])\n\n\n\nA.shape, b.shape, (b@A).shape\n\n((2, 2), (1, 2), (1, 2))\n\n\n- 당연히 아래는 성립안한다.\n\nA = np.array([1,2,3,4]).reshape(2,2) \nb = np.array([1,2]).reshape(2,1) \nb@A\n\nValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)->(n?,m?) (size 2 is different from 1)\n\n\n\nA = np.array([1,2,3,4]).reshape(2,2) \nb = np.array([1,2]).reshape(1,2) \nA@b\n\nValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)->(n?,m?) (size 1 is different from 2)\n\n\n- 아래는 어떨까? 계산가능할까? \\(\\to\\) 모두 계산가능! - (2,) @ (2,2) = (2,) - (2,2) @ (2,) = (2,)\n\nA = np.array([1,2,3,4]).reshape(2,2)\nb = np.array([1,2]) \nA@b\n\narray([ 5, 11])\n\n\n\nA.shape, b.shape, (A@b).shape \n\n((2, 2), (2,), (2,))\n\n\n\nb를 마치 (2,1)처럼 해석하여 행렬곱하고 결과는 다시 (2,) 로 만든것 같다.\n\n\nb@A\n\narray([ 7, 10])\n\n\n\nA.shape, b.shape, (b@A).shape \n\n((2, 2), (2,), (2,))\n\n\n\n이때는 \\(b\\)를 마치 (1,2)처럼 해석하여 행렬곱하고 결과는 다시 (2,)로 만든것 같다.\n\n- 아래는 어떠할까?\n\nb1 = np.array([1,2,3,4]) \nb2 = np.array([1,2,3,4]) \nb1@b2 \n\n30\n\n\n\nb1.shape, b2.shape, (b1@b2).shape \n\n((4,), (4,), ())\n\n\n\n(1,4) @ (4,1) = (1,1) 로 생각\n\n- 즉 위는 아래와 같이 해석하고 행렬곱한것과 결과가 같다.\n\nb1 = np.array([1,2,3,4]).reshape(1,4) \nb2 = np.array([1,2,3,4]).reshape(4,1) \nb1@b2 \n\narray([[30]])\n\n\n\nb1.shape, b2.shape, (b1@b2).shape \n\n((1, 4), (4, 1), (1, 1))\n\n\n- 때로는 (4,1) @ (1,4)와 같은 계산결과를 얻고 싶을 수 있는데 이때는 차원을 명시해야함\n\nb1 = np.array([1,2,3,4]).reshape(4,1) \nb2 = np.array([1,2,3,4]).reshape(1,4) \nb1@b2 \n\narray([[ 1,  2,  3,  4],\n       [ 2,  4,  6,  8],\n       [ 3,  6,  9, 12],\n       [ 4,  8, 12, 16]])"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#차원",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#차원",
    "title": "06wk-1: Numpy (1)",
    "section": "차원",
    "text": "차원\n- 넘파이배열의 차원은 .shape 으로 확인가능\n- 아래는 모두 미묘하게 다르다.\n\na=np.array(3.14) # 스칼라, 0d array \na, a.shape\n\n(array(3.14), ())\n\n\n\na=np.array([3.14]) # 벡터, 1d array \na, a.shape\n\n(array([3.14]), (1,))\n\n\n\na=np.array([[3.14]]) # 매트릭스, 2d array \na, a.shape\n\n(array([[3.14]]), (1, 1))\n\n\n\na=np.array([[[3.14]]]) # 텐서, 3d array \na, a.shape\n\n(array([[[3.14]]]), (1, 1, 1))"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#np.concatenate",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#np.concatenate",
    "title": "06wk-1: Numpy (1)",
    "section": "np.concatenate",
    "text": "np.concatenate\n- 기본예제\n\na=np.array([1,2]) \nb=-a\n\n\nnp.concatenate([a,b]) \n\narray([ 1,  2, -1, -2])\n\n\n- 응용\n\na=np.array([1,2])\nb=-a \nc=np.array([3,4,5])\n\n\nnp.concatenate([a,b,c])\n\narray([ 1,  2, -1, -2,  3,  4,  5])\n\n\n\n여기까진 딱히 칸캐터네이트의 메리트가 없어보임\n리스트였다면 a+b+c 하면 되는 기능이니까?\n\n- 2d array에 적용해보자.\n\na=np.arange(4).reshape(2,2) \nb=-a\n\n\nnp.concatenate([a,b]) \n\narray([[ 0,  1],\n       [ 2,  3],\n       [ 0, -1],\n       [-2, -3]])\n\n\n- 옆으로 붙일려면?\n\nnp.concatenate([a,b],axis=1)\n\narray([[ 0,  1,  0, -1],\n       [ 2,  3, -2, -3]])\n\n\n- 위의 코드에서 axis=1 이 뭐지? axis=0,2 등을 치면 결과가 어떻게 될까?\n\nnp.concatenate([a,b],axis=0)\n\narray([[ 0,  1],\n       [ 2,  3],\n       [ 0, -1],\n       [-2, -3]])\n\n\n\n이건 그냥 np.concatenate([a,b])와 같다.\nnp.concatenate([a,b])는 np.concatenate([a,b],axis=0)의 생략버전이군?\n\n\nnp.concatenate([a,b],axis=2)\n\nAxisError: axis 2 is out of bounds for array of dimension 2\n\n\n\n이런건 없다.\n\n- axis의 의미가 뭔지 궁금함. 좀 더 예제를 살펴보자.\n\na=np.array(range(2*3*4)).reshape(2,3,4)\na\n\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n\n\n\nb=-a\nb\n\narray([[[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]],\n\n       [[-12, -13, -14, -15],\n        [-16, -17, -18, -19],\n        [-20, -21, -22, -23]]])\n\n\n\nnp.concatenate([a,b],axis=0) \n\narray([[[  0,   1,   2,   3],\n        [  4,   5,   6,   7],\n        [  8,   9,  10,  11]],\n\n       [[ 12,  13,  14,  15],\n        [ 16,  17,  18,  19],\n        [ 20,  21,  22,  23]],\n\n       [[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]],\n\n       [[-12, -13, -14, -15],\n        [-16, -17, -18, -19],\n        [-20, -21, -22, -23]]])\n\n\n\nnp.concatenate([a,b],axis=1) \n\narray([[[  0,   1,   2,   3],\n        [  4,   5,   6,   7],\n        [  8,   9,  10,  11],\n        [  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]],\n\n       [[ 12,  13,  14,  15],\n        [ 16,  17,  18,  19],\n        [ 20,  21,  22,  23],\n        [-12, -13, -14, -15],\n        [-16, -17, -18, -19],\n        [-20, -21, -22, -23]]])\n\n\n\nnp.concatenate([a,b],axis=2) \n\narray([[[  0,   1,   2,   3,   0,  -1,  -2,  -3],\n        [  4,   5,   6,   7,  -4,  -5,  -6,  -7],\n        [  8,   9,  10,  11,  -8,  -9, -10, -11]],\n\n       [[ 12,  13,  14,  15, -12, -13, -14, -15],\n        [ 16,  17,  18,  19, -16, -17, -18, -19],\n        [ 20,  21,  22,  23, -20, -21, -22, -23]]])\n\n\n\n이번에는 axis=2까지 된다?\n\n\nnp.concatenate([a,b],axis=3) \n\nAxisError: axis 3 is out of bounds for array of dimension 3\n\n\n\naxis=3까지는 안된다?\n\n- 뭔가 나름의 방식으로 합쳐지는데 원리가 뭘까?\n(분석1) np.concatenate([a,b],axis=0)\n\na=np.array(range(2*3*4)).reshape(2,3,4) \nb=-a \n\n\na.shape, b.shape, np.concatenate([a,b],axis=0).shape\n\n((2, 3, 4), (2, 3, 4), (4, 3, 4))\n\n\n\n첫번째차원이 바뀌었다 => 첫번째 축이 바뀌었다 => axis=0 (파이썬은 0부터 시작하니까!)\n\n(분석2) np.concatenate([a,b],axis=1)\n\na=np.array(range(2*3*4)).reshape(2,3,4) \nb=-a \n\n\na.shape, b.shape, np.concatenate([a,b],axis=1).shape\n\n((2, 3, 4), (2, 3, 4), (2, 6, 4))\n\n\n\n두번째차원이 바뀌었다 => 두번째 축이 바뀌었다 => axis=1\n\n(분석3) np.concatenate([a,b],axis=2)\n\na=np.array(range(2*3*4)).reshape(2,3,4) \nb=-a \n\n\na.shape, b.shape, np.concatenate([a,b],axis=2).shape\n\n((2, 3, 4), (2, 3, 4), (2, 3, 8))\n\n\n\n세번째차원이 바뀌었다 => 세번째 축이 바뀌었다 => axis=2\n\n(분석4) np.concatenate([a,b],axis=3)\n\na=np.array(range(2*3*4)).reshape(2,3,4) \nb=-a \n\n\na.shape, b.shape, np.concatenate([a,b],axis=3).shape\n\nAxisError: axis 3 is out of bounds for array of dimension 3\n\n\n\n네번째차원이 없다 => 네번째 축이 없다 => axis=3으로 하면 에러가 난다.\n\n(보너스1)\n\na=np.array(range(2*3*4)).reshape(2,3,4) \nb=-a \n\n\nnp.concatenate([a,b],axis=-1)\n\narray([[[  0,   1,   2,   3,   0,  -1,  -2,  -3],\n        [  4,   5,   6,   7,  -4,  -5,  -6,  -7],\n        [  8,   9,  10,  11,  -8,  -9, -10, -11]],\n\n       [[ 12,  13,  14,  15, -12, -13, -14, -15],\n        [ 16,  17,  18,  19, -16, -17, -18, -19],\n        [ 20,  21,  22,  23, -20, -21, -22, -23]]])\n\n\n\na.shape, b.shape, np.concatenate([a,b],axis=-1).shape\n\n((2, 3, 4), (2, 3, 4), (2, 3, 8))\n\n\n\n마지막 차원이 바뀌었다 => 마지막 축이 바뀌었다 => axis = -1\n\n(보너스2)\n\na=np.array(range(2*3*4)).reshape(2,3,4) \nb=-a \n\n\nnp.concatenate([a,b],axis=-2)\n\narray([[[  0,   1,   2,   3],\n        [  4,   5,   6,   7],\n        [  8,   9,  10,  11],\n        [  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]],\n\n       [[ 12,  13,  14,  15],\n        [ 16,  17,  18,  19],\n        [ 20,  21,  22,  23],\n        [-12, -13, -14, -15],\n        [-16, -17, -18, -19],\n        [-20, -21, -22, -23]]])\n\n\n\na.shape, b.shape, np.concatenate([a,b],axis=-2).shape\n\n((2, 3, 4), (2, 3, 4), (2, 6, 4))\n\n\n\n마지막에서 2번째 차원이 바뀌었다 => 마지막에서 2번째 축이 바뀌었다 => axis = -2\n\n(보너스3)\n\na=np.array(range(2*3*4)).reshape(2,3,4) \nb=-a \n\n\nnp.concatenate([a,b],axis=-3)\n\narray([[[  0,   1,   2,   3],\n        [  4,   5,   6,   7],\n        [  8,   9,  10,  11]],\n\n       [[ 12,  13,  14,  15],\n        [ 16,  17,  18,  19],\n        [ 20,  21,  22,  23]],\n\n       [[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]],\n\n       [[-12, -13, -14, -15],\n        [-16, -17, -18, -19],\n        [-20, -21, -22, -23]]])\n\n\n\na.shape, b.shape, np.concatenate([a,b],axis=-3).shape\n\n((2, 3, 4), (2, 3, 4), (4, 3, 4))\n\n\n\n마지막에서 3번째 차원이 바뀌었다 => 마지막에서 3번째 축이 바뀌었다 => axis = -3\n\n(보너스3)\n\na=np.array(range(2*3*4)).reshape(2,3,4) \nb=-a \n\n\nnp.concatenate([a,b],axis=-4)\n\nAxisError: axis -4 is out of bounds for array of dimension 3\n\n\n\n마지막에서 4번째 차원은 없다 => 마지막에서 4번째 축이 없다 => axis = -4는 에러가 난다.\n\n- 0차원은 축이 없으므로 concatenate를 쓸 수 없다.\n\na= np.array(1)\nb= np.array(-1) \n\n\na.shape, b.shape\n\n((), ())\n\n\n\nnp.concatenate([a,b])\n\nValueError: zero-dimensional arrays cannot be concatenated\n\n\n- 꼭 a,b가 같은 차원일 필요는 없다.\n\na=np.array(range(4)).reshape(2,2) \nb=np.array(range(2)).reshape(2,1)  \n\n\nnp.concatenate([a,b],axis=1)\n\narray([[0, 1, 0],\n       [2, 3, 1]])\n\n\n\na.shape, b.shape, np.concatenate([a,b],axis=1).shape\n\n((2, 2), (2, 1), (2, 3))"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#np.stack",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#np.stack",
    "title": "06wk-1: Numpy (1)",
    "section": "np.stack",
    "text": "np.stack\n- 혹시 아래가 가능할까?\n\n(3,) 결합 (3,) => (3,2)\n\n\na=np.array([1,2,3])\nb=-a\n\n\na,b\n\n(array([1, 2, 3]), array([-1, -2, -3]))\n\n\n\nnp.concatenate([a,b],axis=1)\n\nAxisError: axis 1 is out of bounds for array of dimension 1\n\n\n\n불가능\n\n- 아래와 같이 하면 해결가능\n\na=np.array([1,2,3]).reshape(3,1) \nb=-a\n\n\na,b\n\n(array([[1],\n        [2],\n        [3]]),\n array([[-1],\n        [-2],\n        [-3]]))\n\n\n\nnp.concatenate([a,b],axis=1)\n\narray([[ 1, -1],\n       [ 2, -2],\n       [ 3, -3]])\n\n\n\n분석: (3) (3) => (3,1) (3,1) => (3,1) concat (3,1)\n\n- 위의 과정을 줄여서 아래와 같이 할 수 있다.\n\na=np.array([1,2,3])\nb=-a\n\n\nnp.stack([a,b],axis=1)\n\narray([[ 1, -1],\n       [ 2, -2],\n       [ 3, -3]])\n\n\n- 아래도 가능\n\nnp.stack([a,b],axis=0)\n\narray([[ 1,  2,  3],\n       [-1, -2, -3]])\n\n\n- 분석해보고 외우자\n(분석1)\n\na=np.array([1,2,3])\nb=-a\n\n\na.shape, b.shape, np.stack([a,b],axis=0).shape\n\n((3,), (3,), (2, 3))\n\n\n\n\n\n=> 첫 위치에 축을 추가 (axis=0) => (1,3) (1,3) => (2,3)\n\n\n\n(분석2)\n\na=np.array([1,2,3])\nb=-a\n\n\na.shape, b.shape, np.stack([a,b],axis=1).shape\n\n((3,), (3,), (3, 2))\n\n\n\n\n\n=> 두 위치에 축을 추가 (axis=1) => (3,1) (3,1) => (3,2)\n\n\n\n- 고차원예제\n\na=np.arange(3*4*5).reshape(3,4,5) \nb=-a\n\n\na.shape, b.shape\n\n((3, 4, 5), (3, 4, 5))\n\n\n\nnp.stack([a,b],axis=0).shape # (3,4,5) => (1,3,4,5) // 첫 위치에 축이 추가되고 스택 \n\n(2, 3, 4, 5)\n\n\n\nnp.stack([a,b],axis=1).shape # (3,4,5) => (3,1,4,5) // 두번째 위치에 축이 추가되고 스택 \n\n(3, 2, 4, 5)\n\n\n\nnp.stack([a,b],axis=2).shape # (3,4,5) => (3,4,1,5) // 세번째 위치에 축이 추가되고 스택 \n\n(3, 4, 2, 5)\n\n\n\nnp.stack([a,b],axis=3).shape # (3,4,5) => (3,4,5,1) // 네번째 위치에 축이 추가되고 스택 \n\n(3, 4, 5, 2)\n\n\n\nnp.stack([a,b],axis=-1).shape # axis=-1 <=> axis=3 \n\n(3, 4, 5, 2)\n\n\n\nnp.stack([a,b],axis=-2).shape # axis=-2 <=> axis=2\n\n(3, 4, 2, 5)\n\n\nnp.concatenate 는 축의 총 갯수를 유지하면서 결합, np.stack은 축의 갯수를 하나 증가시키면서 결합"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#sum",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#sum",
    "title": "06wk-1: Numpy (1)",
    "section": "sum",
    "text": "sum\n- 1차원\n\na = np.array([1,2,3]) \na\n\narray([1, 2, 3])\n\n\n\na.sum()\n\n6\n\n\n\na.sum(axis=0)\n\n6\n\n\n- 2차원\n\na=np.array(range(6)).reshape(2,3)\na\n\narray([[0, 1, 2],\n       [3, 4, 5]])\n\n\n\na.sum() # 전체합\n\n15\n\n\n\na.sum(axis=0) \n\narray([3, 5, 7])\n\n\n\na.sum(axis=1) \n\narray([ 3, 12])\n\n\n- 2차원 결과 분석\n\na.shape, a.sum(axis=0).shape\n\n((2, 3), (3,))\n\n\n\n첫번째 축이 삭제됨 => axis=0\n\n\na.shape, a.sum(axis=1).shape\n\n((2, 3), (2,))\n\n\n\n두번째 축이 삭제됨 => axis=1\n\n- 연습\n\na=np.array(range(10)).reshape(5,2) \na\n\narray([[0, 1],\n       [2, 3],\n       [4, 5],\n       [6, 7],\n       [8, 9]])\n\n\n(문제1) 1열의 합, 2열의 합을 계산하고 싶다면?\n(풀이) 차원이 (5,2) => (2,) 로 나와야 한다. (그럼 첫번째 축이 삭제되어야 하네?)\n\na.sum(axis=0)\n\narray([20, 25])\n\n\n(문제2) 1행의 합, 2행의 합, … , 5행의 합을 계산하고 싶다면?\n(풀이) 차원이 (5,2) => (5,)로 나와야 한다. (그럼 두번째 축이 삭제되어야 하네?)\n\na.sum(axis=1)\n\narray([ 1,  5,  9, 13, 17])\n\n\n(문제3) a의 모든원소의 합을 계산하고 싶다면?\n(풀이) 차원이 (5,2) => () 로 나와야 한다. (첫번째축, 두번째축이 모두 삭제되어야 하네?)\n\na.sum(axis=(0,1))\n\n45\n\n\n\na.sum() # 즉 a.sum(axis=(0,1))이 디폴트값임 \n\n45"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#mean-std-max-min-prod",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#mean-std-max-min-prod",
    "title": "06wk-1: Numpy (1)",
    "section": "mean, std, max, min, prod",
    "text": "mean, std, max, min, prod\n- 모두 sum이랑 유사한 논리\n\na=np.array(range(10)).reshape(5,2)\na\n\narray([[0, 1],\n       [2, 3],\n       [4, 5],\n       [6, 7],\n       [8, 9]])\n\n\n\na.mean(axis=0), a.std(axis=0), a.max(axis=0), a.min(axis=0), a.prod(axis=0)\n\n(array([4., 5.]),\n array([2.82842712, 2.82842712]),\n array([8, 9]),\n array([0, 1]),\n array([  0, 945]))\n\n\n\na.mean(axis=1), a.std(axis=1), a.max(axis=1), a.min(axis=1), a.prod(axis=1)\n\n(array([0.5, 2.5, 4.5, 6.5, 8.5]),\n array([0.5, 0.5, 0.5, 0.5, 0.5]),\n array([1, 3, 5, 7, 9]),\n array([0, 2, 4, 6, 8]),\n array([ 0,  6, 20, 42, 72]))\n\n\n- 참고로 std는 분포를 n으로 나눈다.\n\na=np.array([1,2,3,4])\na.std()\n\n1.118033988749895\n\n\n\nnp.sqrt(sum((a-a.mean())**2)/4)\n\n1.118033988749895\n\n\n- 분모를 n-1로 나눌려면?\n\na=np.array([1,2,3,4])\na.std(ddof=1)\n\n1.2909944487358056\n\n\n\nnp.sqrt(sum((a-a.mean())**2)/3)\n\n1.2909944487358056"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#argmax-argmin",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#argmax-argmin",
    "title": "06wk-1: Numpy (1)",
    "section": "argmax, argmin",
    "text": "argmax, argmin\n- 1차원\n\na= np.array([1,-2,3,10,4])\na\n\narray([ 1, -2,  3, 10,  4])\n\n\n\na.argmax() # 가장 큰 값이 위치한 원소의 인덱스를 리턴 \n\n3\n\n\n\na.argmin() # 가장 작은 값이 위치한 원소의 인덱스를 리턴 \n\n1\n\n\n- 2차원\n\nnp.random.seed(43052)\na=np.random.randn(4*5).reshape(4,5)\na\n\narray([[ 0.38342049,  1.0841745 ,  1.14277825,  0.30789368,  0.23778744],\n       [ 0.35595116, -1.66307542, -1.38277318, -1.92684484, -1.4862163 ],\n       [ 0.00692519, -0.03488725, -0.34357323,  0.70895648, -1.55100608],\n       [ 1.34565583, -0.05654272, -0.83017342, -1.46395159, -0.35459593]])\n\n\n\na.argmin(), a.min()\n\n(8, -1.9268448358915802)\n\n\n\na.argmax(), a.max()\n\n(15, 1.3456558341738827)\n\n\n\na.argmin(axis=0), a.argmin(axis=1)\n\n(array([2, 1, 1, 1, 2]), array([4, 3, 4, 3]))\n\n\n\na.argmax(axis=0), a.argmax(axis=1)\n\n(array([3, 0, 0, 2, 0]), array([2, 0, 3, 0]))"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#cumsum-cumprod",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#cumsum-cumprod",
    "title": "06wk-1: Numpy (1)",
    "section": "cumsum, cumprod",
    "text": "cumsum, cumprod\n- 1차원\n\na=np.array([1,2,3,4])\na\n\narray([1, 2, 3, 4])\n\n\n\na.cumsum()\n\narray([ 1,  3,  6, 10])\n\n\n\na.cumprod()\n\narray([ 1,  2,  6, 24])\n\n\n- 2차원\n\na=np.array(range(3*4)).reshape(3,4)\na\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n\n\na.cumsum(axis=0), a.cumsum(axis=1)\n\n(array([[ 0,  1,  2,  3],\n        [ 4,  6,  8, 10],\n        [12, 15, 18, 21]]),\n array([[ 0,  1,  3,  6],\n        [ 4,  9, 15, 22],\n        [ 8, 17, 27, 38]]))\n\n\n\na.cumprod(axis=0), a.cumprod(axis=1)\n\n(array([[  0,   1,   2,   3],\n        [  0,   5,  12,  21],\n        [  0,  45, 120, 231]]),\n array([[   0,    0,    0,    0],\n        [   4,   20,  120,  840],\n        [   8,   72,  720, 7920]]))"
  },
  {
    "objectID": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#diff",
    "href": "posts/02_ImportantLibraries/2023-04-10-6wk-1.html#diff",
    "title": "06wk-1: Numpy (1)",
    "section": "diff",
    "text": "diff\n- 1차차분\n\na=np.array([1,2,4,6,7])\na\n\narray([1, 2, 4, 6, 7])\n\n\n\nnp.diff(a)\n\narray([1, 2, 2, 1])\n\n\n- 2차차분\n\nnp.diff(np.diff(a))\n\narray([ 1,  0, -1])\n\n\n- prepend, append\n\na=np.array([1,2,4,6,7])\na\n\narray([1, 2, 4, 6, 7])\n\n\n\nnp.diff(a,prepend=100)\n#np.diff(np.array([100]+a.tolist()) )\n\narray([-99,   1,   2,   2,   1])\n\n\n\n[1,2,4,6,7] -> [100,1,2,3,4,6] -> np.diff\n\n\nnp.diff(a,append=100)\n#np.diff(np.array(a.tolist()+[100]) )\n\narray([ 1,  2,  2,  1, 93])\n\n\n(예제) a=[1,2,4,6,7]의 앞에 1을 추가하여 차분하라.\n\nnp.diff(a,prepend=a[0])\n#np.diff(a,prepend=1)\n\narray([0, 1, 2, 2, 1])\n\n\n(예제) a=[1,2,4,6,7]의 뒤에 7을 추가하여 차분하라.\n\nnp.diff(a,append=a[-1])\n#np.diff(a,append=7)\n\narray([1, 2, 2, 1, 0])\n\n\n- 2차원 array의 차분\n\na=np.arange(24).reshape(4,6)\na\n\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 6,  7,  8,  9, 10, 11],\n       [12, 13, 14, 15, 16, 17],\n       [18, 19, 20, 21, 22, 23]])\n\n\n\nnp.diff(a,axis=0) \n\narray([[6, 6, 6, 6, 6, 6],\n       [6, 6, 6, 6, 6, 6],\n       [6, 6, 6, 6, 6, 6]])\n\n\n\nnp.diff(a,axis=1) \n\narray([[1, 1, 1, 1, 1],\n       [1, 1, 1, 1, 1],\n       [1, 1, 1, 1, 1],\n       [1, 1, 1, 1, 1]])"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-22-3wk-2.html#튜플을-왜-쓸까-1",
    "href": "posts/01_PythonBasic/2023-03-22-3wk-2.html#튜플을-왜-쓸까-1",
    "title": "03wk-2: 파이썬의 자료형 (5)",
    "section": "튜플을 왜 쓸까? (1)",
    "text": "튜플을 왜 쓸까? (1)\n- 책의 설명 (이 설명이 꼭 파이썬에 한정되는 것은 아님. 모든 언어에 존재하는 불변형 객체에 적용가능한 설명)\n\n실수방지\n빠르다, 다중작업에 유리하다, 여러사람과 작업하기에 유리하다, 깊은복사/얕은복사시 원하지않는 오류(side effect이라고 함)를 방지할 수 있다, 메모리관리에도 유리함…\n느낌: 불변형은 기능제한이 있는데 가볍고 빠른, 가변형은 기능은 풍부하지만 약간 느리고 무거운 느낌임 (불변형:라면사리, 가변형:라면)"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-22-3wk-2.html#슬기로운-튜플사용-starstarstarstarstar",
    "href": "posts/01_PythonBasic/2023-03-22-3wk-2.html#슬기로운-튜플사용-starstarstarstarstar",
    "title": "03wk-2: 파이썬의 자료형 (5)",
    "section": "슬기로운 튜플사용 (\\(\\star\\star\\star\\star\\star\\))",
    "text": "슬기로운 튜플사용 (\\(\\star\\star\\star\\star\\star\\))\n- 예제: 여러변수를 동시에 출력하고 싶을 경우 (다중출력?)\n변수를 아래와 같이 선언하였다고 하자.\n\na=1\nb=2\nc=3\n\n선언된 값을 확인하려면?\n\na\n\n1\n\n\n\nb\n\n2\n\n\n\nc\n\n3\n\n\n튜플을 이용하면?\n\na,b,c # 괄호하나 생략하는것이 이렇게 편하다..\n\n(1, 2, 3)\n\n\n- 예제: 다중할당1 (여러개의 변수를 동시에 선언하고 싶을 경우)\n\nname, age, sex, height, weight = 'Tom', 20, 'M', 180, 70 \n\n\nname, age, sex, height, weight\n\n('Tom', 20, 'M', 180, 70)\n\n\n\nheight\n\n180\n\n\n- 예제: 다중할당2, 위도와 경도\n\ncoor = (37,127) # 서울 \ncoor\n\n(37, 127)\n\n\n\nlat, long = coor\n\n\nlat \n\n37\n\n\n\nlong \n\n127\n\n\n- 잠깐만: 다중할당은 꼭 튜플에서만 가능한가?\n그건 아니다…\n\n[x,y,z] = [1,2,3] \nx,y,z # 다중출력 \n\n(1, 2, 3)\n\n\n\n[x,y] = 'hi'\nx,y \n\n('h', 'i')\n\n\n튜플과 같이 사용하면 가독성이 극대화 (그래서 다중할당은 거의 튜플과 세트로 사용함)\n\nx,y,z = 1,2,3\nx,y,z # 다중출력 \n\n(1, 2, 3)\n\n\n\nx,y = 'hi'\nx,y \n\n('h', 'i')\n\n\n- 예제: 임시변수 사용없이 두 변수의 값을 교환\n\na=10\nb=20\n\n\na,b = b,a \n\n\na\n\n20\n\n\n\nb\n\n10\n\n\n- 예제: for문과 튜플\n\nlst = [['guebin', 202112345, 'M'],\n       ['iu',202254321, 'F'],\n       ['hodong', 202011223, 'M']]\nlst\n\n[['guebin', 202112345, 'M'],\n ['iu', 202254321, 'F'],\n ['hodong', 202011223, 'M']]\n\n\n\nfor name,studentid,sex in lst: \n    print(name,sex)\n\nguebin M\niu F\nhodong M\n\n\n- 예제: for문과 튜플, dummy variable _\n\nfor name,studentid,sex in lst: \n    print(studentid)\n\n202112345\n202254321\n202011223\n\n\n\nfor _,studentid,_ in lst: \n    print(studentid)\n\n202112345\n202254321\n202011223\n\n\n\nfor _,_,sex in lst: \n    print(sex)\n\nM\nF\nM\n\n\n\nfor name,_,sex in lst: \n    print(name,sex)\n\nguebin M\niu F\nhodong M\n\n\n\nfor name,_  in lst: \n    print(name)\n\nValueError: too many values to unpack (expected 2)\n\n\n\nfor name,*args  in lst: \n    print(name)\n\nguebin\niu\nhodong\n\n\n- 예제: 튜플과 언패킹연산자 *\n\nhead, body, *tail = range(1,11) \nhead, body, tail\n\n(1, 2, [3, 4, 5, 6, 7, 8, 9, 10])\n\n\n\nhead1,head2, *body, tail1,tail2,tail3 = range(1,11) \nhead1,head2, body, tail1,tail2,tail3 \n\n(1, 2, [3, 4, 5, 6, 7], 8, 9, 10)\n\n\n\n*head, body, tail = range(1,11) \nhead, body, tail\n\n([1, 2, 3, 4, 5, 6, 7, 8], 9, 10)\n\n\n(관찰)\n그러고 보니까..\nhead1,head2, body, tail1,tail2,tail3  = (1, 2, [3,4,5,6,7], 8, 9, 10)\nhead1,head2, *body, tail1,tail2,tail3   = (1, 2, 3,4,5,6,7, 8, 9, 10)\n이렇다는 거잖아?\n*를 붙이면 1차원 자료구조가 풀린다..?\n\n*[1,2,3]\n\nSyntaxError: can't use starred expression here (<ipython-input-37-63179bdb9a80>, line 1)\n\n\n\nprint([1,2,3])\n\n[1, 2, 3]\n\n\n\nprint(*[1,2,3]) ## 이런 느낌이란 말이지..\n\n1 2 3"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-22-3wk-2.html#튜플을-왜-쓸까-2",
    "href": "posts/01_PythonBasic/2023-03-22-3wk-2.html#튜플을-왜-쓸까-2",
    "title": "03wk-2: 파이썬의 자료형 (5)",
    "section": "튜플을 왜 쓸까? (2)",
    "text": "튜플을 왜 쓸까? (2)\n- 책의 설명 (이 설명이 꼭 파이썬에 한정되는 것은 아님. 모든 언어에 존재하는 불변형 객체에 적용가능한 설명)\n\n실수방지\n빠르다, 다중작업에 유리하다, 여러사람과 작업하기에 유리하다, 깊은복사/얕은복사시 원하지않는 오류(side effect이라고 함)를 방지할 수 있다, 메모리관리에도 유리함…\n느낌: 불변형은 기능제한이 있는데 가볍고 빠른, 가변형은 기능은 풍부하지만 약간 느리고 무거운 느낌임 (불변형:라면사리, 가변형:라면)\n\n- 내 설명: 소괄화 생략할 수 있어서 쓰는거야\n\n튜플의 장점은 소괄호의 생략에 있음 (이것은 파이썬과 줄리아만 가능)\n소괄호생략 + 언패킹 \\(\\Rightarrow\\) 엄청난 가독성\n컴공과 사람들 의견: 튜플 + 언패킹 \\(\\Rightarrow\\) 엄청난 가독성 \\(\\Rightarrow\\) 충격 \\(\\Rightarrow\\) “파이썬 편하더라고요..”\n\n\ndef mycal(a,b):\n    return a+b, a-b, a*b, a/b  #여러개의 값을 리턴하는듯 보임. -> 사실은 길이가 4인 튜플 1개를 리턴\n\n\nmycal(2,3)\n\n(5, -1, 6, 0.6666666666666666)\n\n\n\n_, _, mulrslt, _ = mycal(2,3) # 병렬할당 \n\n\nmulrslt\n\n6\n\n\n- 의문: 왜 튜플만 괄호를 생략할 수 있지?\n답이 없는 문제인데 답을 해보겠습니다.\n\n튜플을 먼저 만들고, 괄호를 생략하는 문법을 추가한것은 아닐것임\n원래 괄호없이 컴마만 대충찍어서 선언가능한 아주간단한 타입의 벡터형을 만들고 싶었을 것임.\n왜? 괄호없는 벡터를 만들고, 언패킹을 사용하면 여러가지 구문들이 엄청나게 간단해짐.\n컴마컴마로 선언하는 벡터는 한 두번 쓰고 버리는 경우가 많으며 대부분 이름도 필요없음 \\(\\to\\) 원소에 접근해서 sorting하여 순서를 바꾸고 싶다던가 원소를 추가할 이유가 없음 \\(\\to\\) 비싼 가변형으로 만들 이유가 없다는 것..\n우리가 필요한 것: 데이터가 벡터의 형태로 모여있기만 하면 된다!"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-08-1wk-2.html",
    "href": "posts/01_PythonBasic/2023-03-08-1wk-2.html",
    "title": "01wk-2: 파이썬의 자료형 (1)",
    "section": "",
    "text": "강의영상\n\nyoutube: https://youtube.com/playlist?list=PLQqh36zP38-w17wsQ3-WMvDNNWEX52GOX\n\n\n\nIntro\n- 파이썬의 기본자료형은 int, float, bool, str, list, tuple, dict, set 등이 있다.\n\n0차원 자료형: int, float, bool\n1차원 자료형: str, list, tuple, dict, set\n\n\n\nint, float, bool\n- int형\n\na=100\n\n\ntype(a)\n\nint\n\n\n- float형\n\na=1.2*3\na\n\n3.5999999999999996\n\n\n\ntype(a)\n\nfloat\n\n\n\na?\n\n\nType:        float\nString form: 3.5999999999999996\nDocstring:   Convert a string or number to a floating point number, if possible.\n\n\n\n\n- bool형\n\na=True ## 숫자1으로 생각할 수 있음 \nb=False ## 숫자0으로 생각할 수 있음\n\n\ntype(a)\n\nbool\n\n\n\ntype(b)\n\nbool\n\n\n\na?\n\n\nType:        bool\nString form: True\nDocstring:  \nbool(x) -> bool\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.\n\n\n\n\n\nb?\n\n\nType:        bool\nString form: False\nDocstring:  \nbool(x) -> bool\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.\n\n\n\n\n- bool형의 연산\n\na=True ## 1\nb=False ## 0 \n\n\na+b\n\n1\n\n\n\na*b \n\n0\n\n\n- complex형\n\na=1+2j\nb=2-2j\n\n\ntype(a)\n\ncomplex\n\n\n\ntype(b)\n\ncomplex\n\n\n\na?\n\n\nType:        complex\nString form: (1+2j)\nDocstring:  \nCreate a complex number from a real part and an optional imaginary part.\nThis is equivalent to (real + imag*1j) where imag defaults to 0.\n\n\n\n\n\nb?\n\n\nType:        complex\nString form: (2-2j)\nDocstring:  \nCreate a complex number from a real part and an optional imaginary part.\nThis is equivalent to (real + imag*1j) where imag defaults to 0.\n\n\n\n\n\nc=a+b\n\n\nc\n\n(3+0j)\n\n\n- 형태변환: float \\(\\to\\) int\n(예시1)\n\na=3.0\ntype(a)\n\nfloat\n\n\n\na=int(a)\n\n\ntype(a)\n\nint\n\n\n(예시2) 이경우는 정보의 손실이 발생\n\na=3.14 \nint(a)\n\n3\n\n\n- 형태변환: int \\(\\to\\) float\n\na=3\ntype(a)\n\nint\n\n\n\na=float(a)\ntype(a)\n\nfloat\n\n\n- 형태변환: bool \\(\\to\\) int/float, int/float \\(\\to\\) bool\n(예시1)\n\na=True\ntype(a)\n\nbool\n\n\n\nint(a)\n\n1\n\n\n\nfloat(a)\n\n1.0\n\n\n(예시2)\n\na=1 \nbool(a)\n\nTrue\n\n\n\na=0\nbool(a)\n\nFalse\n\n\n(예시3)\n\na=1.0\nbool(a)\n\nTrue\n\n\n\na=0.0\nbool(a)\n\nFalse\n\n\n- 이상한 형태변환도 가능하다. (이런것도 바꿔주나 싶은것도 바꿔줌)\n\nbool(-3.14)\n\nTrue\n\n\n\n저는 이런 코드를 의도적으로 사용하지 않아요..\n\n\nint(3.14)\n\n3\n\n\n- 형태변환이 항상가능한것도 아님\n\nfloat(3+0j) # 사실상 3+0j=3 이므로 float으로 형변환하면 3.0이 되어야 할 것 같은데 변환불가능하다. \n\nTypeError: can't convert complex to float\n\n\n- 암묵적형변환 (implicit)\n(예비학습) implicit의 의미\n\n추운날씨 -> 보일러좀 틀자! (explicit) / 오늘 날씨 좀 추운 것 같지 않아? (implicit)\n짜장면 먹을래? -> 싫어! (explicit) / 난 어제 짜장면 먹었는데.. (implicit)\n\n(예제)\n\nTrue * 1 # 1을 곱할건데 너 계속 True로 있을꺼야? \n\n1\n\n\n\n1 * 1.0 # 1.0을 곱할건데 너 계속 int로 있을꺼야? \n\n1.0\n\n\n\nTrue+True # +연산을 할건데 계속 True로 있을꺼야? \n\n2\n\n\n\n\n숙제\n아래 강의노트의 영상 1-3을 참고하여 주피터랩을 설치하고 설치성공한 화면을 스크린샷으로 LMS에 제출\nhttps://guebin.github.io/IP2022/2022/03/07/(1주차)-3월7일.html"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-원소-추가",
    "href": "posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-원소-추가",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "리스트 원소 추가",
    "text": "리스트 원소 추가\n(예제) 비어있는 리스트를 만들고 원소 0,1,2를 차례로 추가하여 보자.\n(풀이1) + 연산이용\n\na=[]\na\n\n[]\n\n\n\na= a+[0]\na\n\n[0]\n\n\n\na= a+[1] # a = [0]+[1]\na\n\n[0, 1]\n\n\n\na= a+[2] # a = [0,1] + [2]\na\n\n[0, 1, 2]\n\n\n(풀이2) += 이용\n\na=[]\na+=[0]\na+=[1] \na+=[2] \na\n\n[0, 1, 2]\n\n\n\n반복되는 문자를 제거하고 연산의 순서를 바꾼다.\n\n(풀이3) 리스트 특수기능 .append()를 이용\n\na=[] \n\n\na.append(0)\na.append(1)\na.append(2)\na\n\n[0, 1, 2]\n\n\n- 아래는 불가능하다.\n\na.append(0).append(1).append(2)\n\nAttributeError: 'NoneType' object has no attribute 'append'\n\n\n\na.append(0,1,2)\n\nTypeError: append() takes exactly one argument (3 given)"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-20-3wk-1.html#a4와-a.append4의-차이점은",
    "href": "posts/01_PythonBasic/2023-03-20-3wk-1.html#a4와-a.append4의-차이점은",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "a+[4]와 a.append(4)의 차이점은?",
    "text": "a+[4]와 a.append(4)의 차이점은?\n(관찰1)\n\na=[1,2,3]\na+[4] ## 리스트 a와 리스트 [4]의 연산결과를 알려줘 \n\n[1, 2, 3, 4]\n\n\n\na ## a는 그대로임. 변화없음 \n\n[1, 2, 3]\n\n\n(관찰2)\n\na=[1,2,3]\na.append(4)\n\n\na ## a자체가 변화함 \n\n[1, 2, 3, 4]\n\n\n비슷해보이지만 굉장히 미묘한 차이가 있음\na.append(4): a에 4를 append하라 \\(\\to\\) a가 변함\na+[4]: a와 [4]를 연산하라"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-특수기능",
    "href": "posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-특수기능",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "리스트 특수기능",
    "text": "리스트 특수기능\n(append)\n\na=[1,2,3,4]\na.append?\n\n\nSignature: a.append(object, /)\nDocstring: Append object to the end of the list.\nType:      builtin_function_or_method\n\n\n\n\na.append(5)\na\n\n[1, 2, 3, 4, 5]\n\n\n(clear)\n\na=[1,2,3,4]\na.clear?\n\n\nSignature: a.clear()\nDocstring: Remove all items from list.\nType:      builtin_function_or_method\n\n\n\n\n\na.clear()\na\n\n[]\n\n\n(copy)\n\na=[1,2,3,4]\na.copy?\n\n\nSignature: a.copy()\nDocstring: Return a shallow copy of the list.\nType:      builtin_function_or_method\n\n\n\n\n\nb=a.copy()\nb\n\n[1, 2, 3, 4]\n\n\n(count)\n\na=['a','a','b','b','b','c']\na.count?\n\n\nSignature: a.count(value, /)\nDocstring: Return number of occurrences of value.\nType:      builtin_function_or_method\n\n\n\n\na.count('a')\n\n2\n\n\n\na.count('b')\n\n3\n\n\n\na.count('c')\n\n1\n\n\n(extend)\n\na=[1,2,3,4]\nb=[-1,-2,-3,-4]\n\n\na.extend(b)\na\n\n[1, 2, 3, 4, -1, -2, -3, -4]\n\n\n\na=[1,2,3,4]\nb=[-1,-2,-3,-4]\n\n\na.append(b)\n\n\na\n\n[1, 2, 3, 4, [-1, -2, -3, -4]]\n\n\n(index)\n\na=[11,22,'a',True, 22,'a']\na.index?\n\n\nSignature: a.index(value, start=0, stop=9223372036854775807, /)\nDocstring:\nReturn first index of value.\nRaises ValueError if the value is not present.\nType:      builtin_function_or_method\n\n\n\n\na.index(11)\n\n0\n\n\n\na.index(22)\n\n1\n\n\n\na.index('a')\n\n2\n\n\n\na.index(True)\n\n3\n\n\n(insert)\n\na=[1,2,3]\na.insert?\n\n\nSignature: a.insert(index, object, /)\nDocstring: Insert object before index.\nType:      builtin_function_or_method\n\n\n\n\na.insert(1,88) \na\n\n[1, 88, 2, 3]\n\n\n(pop)\n\na=['a',1,2,'d']\na.pop?\n\n\nSignature: a.pop(index=-1, /)\nDocstring:\nRemove and return item at index (default last).\nRaises IndexError if list is empty or index is out of range.\nType:      builtin_function_or_method\n\n\n\n\na.pop() # index=-1 이므로 마지막원소가 나타남\n\n'd'\n\n\n\na # a는 마지막 원소가 사라진 상태\n\n['a', 1, 2]\n\n\n\na.pop(0) # index=0 이므로 첫번쨰 원소가 나타남\n\n'a'\n\n\n\na # a에는 첫번째 원소가 사라진 상태\n\n[1, 2]\n\n\n(remove)\n\na=['a',2,3,'d']\na.remove?\n\n\nSignature: a.remove(value, /)\nDocstring:\nRemove first occurrence of value.\nRaises ValueError if the value is not present.\nType:      builtin_function_or_method\n\n\n\n\na.remove('d')\n\n\na\n\n['a', 2, 3]\n\n\n\na.remove('a')\n\n\na\n\n[2, 3]\n\n\n(reverse)\n\na=[1,2,3,4]\na.reverse?\n\n\nSignature: a.reverse()\nDocstring: Reverse *IN PLACE*.\nType:      builtin_function_or_method\n\n\n\n\na.reverse()\na\n\n[4, 3, 2, 1]\n\n\n(sort)\n\na=[1,3,2,4]\na.sort?\n\n\n\nSignature: a.sort(*, key=None, reverse=False)\nDocstring:\nSort the list in ascending order and return None.\nThe sort is in-place (i.e. the list itself is modified) and stable (i.e. the\norder of two equal elements is maintained).\nIf a key function is given, apply it once to each list item and sort them,\nascending or descending, according to their function values.\nThe reverse flag can be set to sort in descending order.\nType:      builtin_function_or_method\n\n\n\n\na.sort()\na\n\n[1, 2, 3, 4]\n\n\n(다른예제들)\n\na=list('guebin')\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n\na.sort()\na\n\n['b', 'e', 'g', 'i', 'n', 'u']\n\n\n\na.sort(reverse=True)\na\n\n['u', 'n', 'i', 'g', 'e', 'b']"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-20-3wk-1.html#중첩리스트",
    "href": "posts/01_PythonBasic/2023-03-20-3wk-1.html#중첩리스트",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "중첩리스트",
    "text": "중첩리스트\n- 리스트는 리스트를 원소로 받을 수 있으므로 아래와 같이 중첩된 리스트를 만들 수 있다.\n\nA=[[1,2,3],\n   [4,5,6],\n   [7,8,9]]\nA\n\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\n- A는 1차원인 벡터가 아니라 2차원인 매트릭스로 이해할 수 있다. 구체적으로는 아래와 같은 매트릭스로 이해할 수 있다\n$\n\\[\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{bmatrix}\\]\n$\n- A에서 (2,1)의 원소를 뽑고싶다 = 4를 뽑고싶다\n\nA[1,0] # R에서는 이게 가능했죠\n\nTypeError: list indices must be integers or slices, not tuple\n\n\n\n실패\n\n\nA[1][0]\n\n4\n\n\n\n성공\n\n- 성공의 이유를 분석해보자.\n\nA\n\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\n\nA[1]\n\n[4, 5, 6]\n\n\n\nA[1][0]\n\n4\n\n\n- 매트릭스는 아니지만 매트릭스 같음! - 1차원 배열을 다차원 배열로 확장할 수 있는 기본 아이디어를 제공함"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-20-3wk-1.html#예비학습1-for문-벼락치기",
    "href": "posts/01_PythonBasic/2023-03-20-3wk-1.html#예비학습1-for문-벼락치기",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "예비학습1: for문 벼락치기",
    "text": "예비학습1: for문 벼락치기\n- 리스트 컴프리헨션을 이해하기 전에 for문에 대하여 알아보자.\n프로그램안에서 반복해서 무엇인가를 하고싶다 \\(\\to\\) for\n\nfor i in [0,1,2,3]: ## 반복실행계획\n    print(i) ## 반복실행할내용, 탭을이용하여 들여쓰기해야한다. \n\n0\n1\n2\n3\n\n\n(예제) 1,2,3,4의 합을 for문을 이용하여 구해보자.\n\n_sum = 0 \n\n\n_sum = 0\nfor i in [1,2,3,4]: \n    _sum = _sum + i \n\n\n_sum\n\n10\n\n\n\n_sum = 0\ni=1 \n_sum = _sum + i ## 1 <= 0+1\ni=2\n_sum = _sum + i ## 3 <= 1+2 \ni=3 \n_sum = _sum + i ## 6 <= 3+3\ni=4\n_sum = _sum + i ## 10 <= 6+4 \n\n\n_sum\n\n10\n\n\n- 궁금: 아래와 같은 코드가 있다고 하자.\nfor i in ????: \n    print(i)\n??? 자리에 올 수 있는건 무엇일까?\n\n대답하기 어려움.\n일단 list는 가능했음.\n\n(예시1)\n\nfor i in [1,2,3,4]: \n    print(i)\n\n1\n2\n3\n4\n\n\n(예시2)\n\nfor i in ['a','b','c','d']: \n    print(i)\n\na\nb\nc\nd\n\n\n(예시3)\n\nfor i in 'abcd': \n    print(i)\n\na\nb\nc\nd\n\n\n(예시4)\n\nfor i in '1': \n    print(i)\n\n1\n\n\n(예시5)\n\nfor i in 1: \n    print(i)\n\nTypeError: 'int' object is not iterable\n\n\n(예시6)\n\nfor i in range(10): \n    print(i)\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-20-3wk-1.html#예비학습2-range",
    "href": "posts/01_PythonBasic/2023-03-20-3wk-1.html#예비학습2-range",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "예비학습2: range",
    "text": "예비학습2: range\n- range(0,10) 선언해보기\n\nrange(0,10)\n\nrange(0, 10)\n\n\n\n이게뭐야?\n\n- 도움말 확인하기\n\n_tmp = range(0,10)\n_tmp?\n\n\nType:        range\nString form: range(0, 10)\nLength:      10\nDocstring:  \nrange(stop) -> range object\nrange(start, stop[, step]) -> range object\nReturn an object that produces a sequence of integers from start (inclusive)\nto stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.\nstart defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.\nThese are exactly the valid indices for a list of 4 elements.\nWhen step is given, it specifies the increment (or decrement).\n\n\n\n\n우리가 아는 범위에서는 모르겠음.. 이런게 있나보다 하고 넘어가야 하겠음\n\n- 형태변환으로 range(0,10)의 느낌 찾기\n\nlist(range(0,10)) # 0을 포함, 10을 미포함 \n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n이게 중요한것임. range(0,10)를 리스트화시키면 [0,1,…,9] 와 같은 리스트를 얻을 수 있음. \\(\\Rightarrow\\) range(0,10)은 [0,1,…,9] 와 “비슷한 것” 임\n\n- range()의 활용\n\nlist(range(10)) # 0은 생략가능\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nlist(range(2,10)) # 2는 포함, 10은 미포함 \n\n[2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nlist(range(1,10,2)) # 2는 포함, 10은 미포함 \n\n[1, 3, 5, 7, 9]"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-컴프리헨션",
    "href": "posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-컴프리헨션",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "리스트 컴프리헨션",
    "text": "리스트 컴프리헨션\n- 예제: \\(2^0, 2^1, 2^2, 2^3\\)를 원소로 가지는 리스트를 생성하라.\n(풀이1) 직접입력\n\nx= [2**0, 2**1, 2**2, 2**3] \nx\n\n[1, 2, 4, 8]\n\n\n(풀이2) for문을 이용함\n\nx=[] \nfor i in [0,1,2,3]:\n    x.append(2**i) \n\n\nx\n\n[1, 2, 4, 8]\n\n\n(풀이3) for문을 이용함\n\nx=[] \nfor i in [0,1,2,3]:\n    x = x+[2**i]\n\n\nx\n\n[1, 2, 4, 8]\n\n\n(풀이4) for문을 이용함\n\nx=[] \nfor i in [0,1,2,3]:\n    x += [2**i]\n\n\nx\n\n[1, 2, 4, 8]\n\n\n(풀이5) 리스트컴프리헨션을 이용한 풀이\n\n[2**i for i in [0,1,2,3]]\n\n[1, 2, 4, 8]\n\n\n- 리스트컴프리헨션의 문법 암기방법\n\n집합에서 조건제시법을 연상\n\\(\\{2^0,2^1,2^2,2^3\\}=\\{2^i: i \\in \\{0,1,2,3\\} \\}\\)\n\n- 리스트컴프리헨션이란?\n\n리스트를 매우 효율적으로 만드는 테크닉\nfor문에 비하여 가지고 있는 장점: (1) 코드가 간결하다 (2) 빠르다"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-컴프리헨션-연습",
    "href": "posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-컴프리헨션-연습",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "리스트 컴프리헨션 연습",
    "text": "리스트 컴프리헨션 연습\n- 예제1: 리스트 컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라.\n\n['SSSS','PPPP','AAAA','MMMM']\n\n['SSSS', 'PPPP', 'AAAA', 'MMMM']\n\n\n(풀이)\n\n[i*4 for i in 'SPAM']\n\n['SSSS', 'PPPP', 'AAAA', 'MMMM']\n\n\n- 예제2: 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라.\n\n['X1','X2','X3','Y1','Y2','Y3']\n\n['X1', 'X2', 'X3', 'Y1', 'Y2', 'Y3']\n\n\n(풀이)\n\n[i+j for i in 'XY' for j in '123']\n\n['X1', 'X2', 'X3', 'Y1', 'Y2', 'Y3']\n\n\n- 예제: 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라.\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n\n(풀이)\n\n[i+j for i in ['stat', 'math'] for j in '123']\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n\n(다른풀이) 참고로 for문을 쓰면 좀 복잡해진다.\n\n_lst = [] \nfor x in ['stat','math']: \n    for y in '123': \n        _lst = _lst + [x+y] \n\n\n_lst \n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n\n- 예제: 리스트컴프리헨션과 문자열 'jbnu'를 이용하여 아래와 같은 리스트를 만들어라.\n\n['j','b','n','u']\n\n['j', 'b', 'n', 'u']\n\n\n(다른풀이) 아래와 같이 풀면 된다는것은 알고 있음\n\nlist('jbnu')\n\n['j', 'b', 'n', 'u']\n\n\n(풀이)\n\n[i for i in 'jbnu']\n\n['j', 'b', 'n', 'u']\n\n\n- 예제: 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라.\n\n['X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10', 'X11', 'X12']\n\n['X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10', 'X11', 'X12']\n\n\n(풀이)\n\n['X'+str(i) for i in range(1,13)]\n#['X'+str(i) for i in list(range(1,13))]\n\n['X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10', 'X11', 'X12']"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-컴프리헨션과-for문의-미묘한-차이",
    "href": "posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-컴프리헨션과-for문의-미묘한-차이",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "리스트 컴프리헨션과 for문의 미묘한 차이",
    "text": "리스트 컴프리헨션과 for문의 미묘한 차이\n(경우1)\n\nx=777 \nlst = [] \nfor x in 'jbnu': \n    lst = lst + [x]\nlst    \n\n['j', 'b', 'n', 'u']\n\n\n\nx\n\n'u'\n\n\n(경우2)\n\nx=777\nlst = [x for x in 'jbnu'] \nlst \n\n['j', 'b', 'n', 'u']\n\n\n\nx\n\n777\n\n\n\n진짜 미묘하게 다르죠?"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-vs-튜플",
    "href": "posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-vs-튜플",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "리스트 vs 튜플",
    "text": "리스트 vs 튜플\n- 컨테이너형타입이라는 점, 그리고 연산 및 인덱싱을 하는 방법은 리스트와 같음 - 차이점1: [] 대신에 ()를 사용한다. - 차이점2: 불변형이다. (원소의 값을 바꿀 수 없음) - 차이점3: 하나의 원소를 선언할 때는 (1,)와 같이 해야 한다. - 차이점4: 의미가 명확할때는 튜플의 ()를 생략가능하다.\n- 컨테이너형이라는 것이 무슨의미?\n\na=(4,6,'pencil', 3.2+4.6j, [3,4]) \n\n\ntype(a[2])\n\nstr\n\n\n\ntype(a[3])\n\ncomplex\n\n\n- 불변형이라는 것은 무슨의미?\n\na[2] = 'Pencil'\n\nTypeError: 'tuple' object does not support item assignment\n\n\n참고로 a를 튜플이 아니라 리스트로 선언하면 값이 잘 바뀐다.\n\na=[4,6,'pencil', 3.2+4.6j, [3,4]]\n\n\na[2]\n\n'pencil'\n\n\n\na[2]='Pencil'\n\n\na\n\n[4, 6, 'Pencil', (3.2+4.6j), [3, 4]]\n\n\n- 하나의 원소로 이루어진 튜플을 만들때는 쉼표를 붙여야 함.\n\n[1]+[2,3,4]\n\n[1, 2, 3, 4]\n\n\n\n(1,)+(2,3,4)\n\n(1, 2, 3, 4)\n\n\n- 마지막차이점! 의미가 명확할때 튜플의 괄호는 생략가능하다. (이게 중요합니다)\n\na=1,2\na\n\n(1, 2)\n\n\n의미가 명확할때 생략해야함\n\n1,2 + 3,4,5 \n\n(1, 5, 4, 5)\n\n\n\n(1,2) + (3,4,5) \n\n(1, 2, 3, 4, 5)"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-20-3wk-1.html#선언",
    "href": "posts/01_PythonBasic/2023-03-20-3wk-1.html#선언",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "선언",
    "text": "선언\n- 소괄호를 이용\n\na=(1,2,3)\na\n\n(1, 2, 3)\n\n\n\ntype(a)\n\ntuple\n\n\n- 생략가능하다는 점이 포인트\n\na=1,2,3\na\n\n(1, 2, 3)\n\n\n\ntype(a)\n\ntuple\n\n\n- 원소가 하나인 튜플을 만들고 싶다면?\n\na=(1,)\na\n\n(1,)"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-20-3wk-1.html#연산",
    "href": "posts/01_PythonBasic/2023-03-20-3wk-1.html#연산",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "연산",
    "text": "연산\n- 리스트와 동일\n\n(1,2)+(3,4,5)\n\n(1, 2, 3, 4, 5)\n\n\n\n(1,2)*2\n\n(1, 2, 1, 2)"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-20-3wk-1.html#인덱싱",
    "href": "posts/01_PythonBasic/2023-03-20-3wk-1.html#인덱싱",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "인덱싱",
    "text": "인덱싱\n- 리스트와 동일\n\na=(1,2,3,-4,-5)\na\n\n(1, 2, 3, -4, -5)\n\n\n\na[-1]\n\n-5\n\n\n\na[-3:]\n\n(3, -4, -5)"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-15-2wk-2.html#선언",
    "href": "posts/01_PythonBasic/2023-03-15-2wk-2.html#선언",
    "title": "02wk-2: 파이썬의 자료형 (3)",
    "section": "선언",
    "text": "선언\n- 리스트의 선언\n\na= [1,2,3,22] \n\n- 비어있는 리스트의 선언\n\na= []\na\n\n[]\n\n\n\na= list()\na\n\n[]"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-15-2wk-2.html#연산",
    "href": "posts/01_PythonBasic/2023-03-15-2wk-2.html#연산",
    "title": "02wk-2: 파이썬의 자료형 (3)",
    "section": "연산",
    "text": "연산\n- 더하기연산\n\n[1,2]+[-3,4,5]\n\n[1, 2, -3, 4, 5]\n\n\n\n우리의 예상과 다른 결과가 나옴 \\(\\to\\) 파이썬은 R처럼 자체적으로 좋은 계산기능을 내장하고 있지 않음.\n\n- 브로드캐스팅과 같이 R에서는 당연히 가능했던 기능을 사용할 수 없음.\n\n[1,2,3,4,5] + 1\n\nTypeError: can only concatenate list (not \"int\") to list\n\n\n- 뺄셈은 정의되지 않음\n\na= [1,2,1,2]\na-[1,2]\n\nTypeError: unsupported operand type(s) for -: 'list' and 'list'\n\n\n- 곱하기는 정의가능\n\n[1,2]*3\n\n[1, 2, 1, 2, 1, 2]\n\n\n- 나눗셈은 정의되지 않음\n\n[1,2,1,2,1,2] /3\n\nTypeError: unsupported operand type(s) for /: 'list' and 'int'\n\n\n- 더하기와 곱하기는 원소의 추가와 반복추가를 의미하지만 그렇다고 해서 뺄셈과 나눗셈이 원소의 삭제를 의미하는것은 아님\n- 더하기와 곱하기가 원소의 추가와 반복추가를 의미하여 편리할때도 있긴하지만, 우리는 산술적인 +, * 를 원하는 경우도 있다. 이럴 경우는 어떻게 할 수 있을까?\n(예제)\n\na=[1,2]\nb=[3,4]\n\na+b = [4,6] 이 되도록 하려면?\n(풀이1)\n\n[a[0]+b[0],a[1]+b[1]]\n\n[4, 6]\n\n\n풀이가 가능한 이유? a,b는 리스트이지만 a[0], a[1], b[0], b[1] 은 각각 인트형임. 인트형은 + 연산이 가능했음.\n(풀이2)\nnumpy 패키지 (파이썬의 여러 수치연산들을 담당하는 라이브러리)\n\n이러한 벡터연산은 누구나 필요로 하는 연산임.\n내가 아니더라도 누군가가 프로그램화 해놓았을 것임.\n그 누군가가 자신이 만든 코드를 잘 정리하여 무료로 배포했을 수도 있음. (패키지를 배포한다고 표현)\n그 패키지를 우리는 가져와서 설치한뒤 사용하기만 하면된다.\n\n패키지를 설치하는 방법\n\n!pip install numpy # 최신버전을 설치함\n!conda install -c conda-forge numpy -y # 안전한 버전을 설치함\n\n설치된 패키지를 사용하는 방법\n\nimport numpy 한뒤에 numpy.??로 기능을 사용\nimport numpy as np 한뒤에 np.??로 기능을 사용\n\n\nimport numpy ## 설치한패키지를 쓰겠다고 선언함 \n\n\na=[1,2]\nb=[3,4]\n\n\naa = numpy.array(a)\nbb = numpy.array(b)\n\n\naa+bb\n\narray([4, 6])\n\n\n여러가지 연산 가능 (마치 R처럼 쓸 수 있음)\n\n2*aa\n\narray([2, 4])\n\n\n\n2*aa+1\n\narray([3, 5])\n\n\n\n2*aa+1+bb\n\narray([6, 9])\n\n\n(풀이3)\n\nimport numpy as np ## 설치한 numpy라는 패키지를 쓰겠음. 그런데 numpy말고 np라는 이름으로 쓰겠음\n\n\nnp.array(a)+np.array(b)\n\narray([4, 6])"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-15-2wk-2.html#인덱싱",
    "href": "posts/01_PythonBasic/2023-03-15-2wk-2.html#인덱싱",
    "title": "02wk-2: 파이썬의 자료형 (3)",
    "section": "인덱싱",
    "text": "인덱싱\n- str형과 동일한 방식\n\na=[11,22,33,44,55] # 0 -4 -3 -2 -1\n\n\na[-2:] # 끝의 2개의 원소를 뽑음 \n\n[44, 55]"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-15-2wk-2.html#콘테이너형-객체",
    "href": "posts/01_PythonBasic/2023-03-15-2wk-2.html#콘테이너형-객체",
    "title": "02wk-2: 파이썬의 자료형 (3)",
    "section": "콘테이너형 객체",
    "text": "콘테이너형 객체\n- 리스트의 원소는 int, float 따위만 가능한 것이 아니다. (리스트는 컨테이너형 객체이므로)\n\nlst = [1,3.14,True,'a',[1,2], \n       (1,2),{'name':'iu','age':27},{1,2,3}]\n\n\nlst\n\n[1, 3.14, True, 'a', [1, 2], (1, 2), {'name': 'iu', 'age': 27}, {1, 2, 3}]\n\n\n각 원소의 타입을 알아보자.\n\ntype(lst[0])\n\nint\n\n\n\ntype(lst[1])\n\nfloat\n\n\n\ntype(lst[2])\n\nbool\n\n\n\ntype(lst[3])\n\nstr\n\n\n\ntype(lst[4])\n\nlist\n\n\n\ntype(lst[5])\n\ntuple\n\n\n\ntype(lst[6])\n\ndict\n\n\n\ntype(lst[7])\n\nset\n\n\n- str은 컨테이너형이 아니다.\n\n'abcd'[2]\n\n'c'\n\n\n\nstr의 모든 원소는 문자임"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-15-2wk-2.html#가변객체",
    "href": "posts/01_PythonBasic/2023-03-15-2wk-2.html#가변객체",
    "title": "02wk-2: 파이썬의 자료형 (3)",
    "section": "가변객체",
    "text": "가변객체\n- 리스트는 원소를 수정할 수 있다. (리스트는 가변객체이므로)\n\na=[11,22,33]\na\n\n[11, 22, 33]\n\n\n\na[0]\n\n11\n\n\n\na[0]=111\n\n\na\n\n[111, 22, 33]\n\n\n- 원소수정은 당연한 기능같은데 이것이 불가능한 경우도 있다.\n(가능한경우)\n\na=['g','u','e','b','i','n']\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n\na[0]\n\n'g'\n\n\n\na[0]='G'\n\n\na\n\n['G', 'u', 'e', 'b', 'i', 'n']\n\n\n(불가능한경우)\n\na='guebin'\na\n\n'guebin'\n\n\n\na[0]\n\n'g'\n\n\n\na[0]='G'\n\nTypeError: 'str' object does not support item assignment"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-15-2wk-2.html#리스트의-원소-삭제",
    "href": "posts/01_PythonBasic/2023-03-15-2wk-2.html#리스트의-원소-삭제",
    "title": "02wk-2: 파이썬의 자료형 (3)",
    "section": "리스트의 원소 삭제",
    "text": "리스트의 원소 삭제\n(예제1) del을 이용한 원소삭제\n아래와 같이 문자로 된 리스트를 선언하자.\n\na=['g','u','e','b','i','n']\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n사실 더 쉽게 선언할 수 있음\n\nlist('guebin')\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n첫번째 원소를 삭제하고 싶다면?\n\ndel a[0]\na\n\n['u', 'e', 'b', 'i', 'n']\n\n\n이 상태에서 다시 첫번째 원소를 삭제한다면?\n\ndel a[0]\na\n\n['e', 'b', 'i', 'n']\n\n\n(예제2) pop을 이용한 원소삭제\n\na=list('guebin')\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n\na.pop(0)\n\n'g'\n\n\n\na\n\n['u', 'e', 'b', 'i', 'n']\n\n\n\na.pop(0)\n\n'u'\n\n\n\na\n\n['e', 'b', 'i', 'n']"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-13-2wk-1.html#선언",
    "href": "posts/01_PythonBasic/2023-03-13-2wk-1.html#선언",
    "title": "02wk-1: 파이썬의 자료형 (2)",
    "section": "선언",
    "text": "선언\n- 예시1\n\na='guebin'\n\n\na\n\n'guebin'\n\n\n- 예시2\n\na=\"guebin\"\n\n\na\n\n'guebin'"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-13-2wk-1.html#연산",
    "href": "posts/01_PythonBasic/2023-03-13-2wk-1.html#연산",
    "title": "02wk-1: 파이썬의 자료형 (2)",
    "section": "연산",
    "text": "연산\n- 더하기(+)연산\n\na='X'\nb='2'\n\n\nc=a+b\nc\n\n'X2'\n\n\n- 빼기(-)연산\n\na='X2'\nb='2'\na-b\n\nTypeError: unsupported operand type(s) for -: 'str' and 'str'\n\n\n\n이런건 없다.\n\n- 곱하기(*)연산\n\na='X'\n\n\na+a+a\n\n'XXX'\n\n\n\na*3 # a*3 = a+a+a = 'X'+'X+'X'\n\n'XXX'\n\n\n아래도 가능하다.\n\n3*a\n\n'XXX'\n\n\n그리고 아래도 가능하다.\n\na='X'\nb=3 \na*b\n\n'XXX'\n\n\n대신에 의미상 맞지 않는 것은 수행되지 않고 에러가 난다.\n\na='X'\nb='Y'\na+b\n\n'XY'\n\n\n\na*b\n\nTypeError: can't multiply sequence by non-int of type 'str'\n\n\n- 나눗셈(/)연산\n\na='XX'\n\n\na/2\n\nTypeError: unsupported operand type(s) for /: 'str' and 'int'\n\n\n\n이런건 없다.."
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-13-2wk-1.html#인덱싱",
    "href": "posts/01_PythonBasic/2023-03-13-2wk-1.html#인덱싱",
    "title": "02wk-1: 파이썬의 자료형 (2)",
    "section": "인덱싱",
    "text": "인덱싱\n- str은 하나의 벡터 문자가 여러개 있는 형태라고 생각하면 된다.\n\na='guebin'\n\n\na\n\n'guebin'\n\n\n\n6개의 칸에 글씨가 하나씩 들어가 있음.\n\n- 대괄호 []안에 숫자를 넣는 방식으로 벡터의 원소를 호출할 수 있다. (주의: 인덱스가 0부터 시작함)\n\na[0] #첫번째원소\n\n'g'\n\n\n\na[1] #두번째원소 \n\n'u'\n\n\n마지막원소는 -1로 호출할 수도 있다.\n\na[-1]\n\n'n'\n\n\n마지막에서 2번째 원소는 -2로 호출가능하다.\n\na[-2]\n\n'i'\n\n\n- 요약하면 아래와 같은 방식으로 호출가능함.\n\n\n\ng\nu\ne\nb\ni\nn\n\n\n\n\n0\n1\n2\n3\n4\n5\n\n\n0\n-5\n-4\n-3\n-2\n-1\n\n\n\n\na[4]\n\n'i'\n\n\n\na[-2]\n\n'i'\n\n\n\na[-4]\n\n'e'\n\n\n- :을 이용하여 여러개의 원소를 호출할 수 있음.\n\na='guebin'\n\n\na[0:3] # a[0],a[1],a[2],a[3]이 아니라 a[0],a[1],a[2]까지만 뽑힌다. 즉 마지막의 3은 호출되지 않는다. \n\n'gue'\n\n\n\na[1:3] # a[1], a[2] 만 호출 // start=1,  stop=3 \n\n'ue'\n\n\nindex=1부터 시작해서 마지막원소까지 호출하려면?\n\na='guebin'\n\n\na[5] # guebin의 마지막원소 'n'이 출려 \n\n'n'\n\n\n\na[1:5] # 5는 포함되지 않으므로 틀림\n\n'uebi'\n\n\n\na[1:6] # 정답\n\n'uebin'\n\n\n안 헷갈리는 방법은 없을까? 생략한다.\n\na[1:]\n\n'uebin'\n\n\n- 생략의 응용1\n\na='k-pop' \na\n\n'k-pop'\n\n\n\na[2:5]\n\n'pop'\n\n\n\na[2:]\n\n'pop'\n\n\n- 생략의 응용2\n\na='k-pop'\na\n\n'k-pop'\n\n\n\na[0:2] # a[0],a[1]\n\n'k-'\n\n\n\na[:2] # a[0],a[1] \n\n'k-'\n\n\n- 생략의 응용3\n\na='k-pop'\na\n\n'k-pop'\n\n\n\na[0:5] # a[0],...,a[4]\n\n'k-pop'\n\n\n\na[:]\n\n'k-pop'"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-13-2wk-1.html#str-특수기능",
    "href": "posts/01_PythonBasic/2023-03-13-2wk-1.html#str-특수기능",
    "title": "02wk-1: 파이썬의 자료형 (2)",
    "section": "str 특수기능",
    "text": "str 특수기능\n- 파이썬의 변수는 단순히 정보를 담는 그릇이 아니다. 유용한 기능을 제공하는 경우가 있다.\n\na='ABCD' # a라는 변수는 'ABCD'라는 정보를 담는 그릇의 역할만 하지 않고, 특화된 어떠한 기능도 제공한다. \na\n\n'ABCD'\n\n\n\na.lower() # a.lower()를 쓰면 a의 모든 문자를 소문자로 바꾸는 기능을 제공, lower(a)라고 읽자!\n\n'abcd'\n\n\n여기에서 lower()는 문자열에 특화된 기능임. 따라서 당연히 아래는 불가능\n\na=3.14\na.lower() # lower(a)\n\nAttributeError: 'float' object has no attribute 'lower'\n\n\n- 자료형에 특화된 기능(=함수)을 확인하는 방법? a.+ tab 으로 목록 확인 가능\n\na='guebin'\n\n\na.upper?\n\n\nSignature: a.upper()\nDocstring: Return a copy of the string converted to uppercase.\nType:      builtin_function_or_method\n\n\n\n\na.upper() # upper(a) \n\n'GUEBIN'\n\n\n\na.capitalize() # capitalize(a) \n\n'Guebin'\n\n\n\na='asdf'\n\n- 문자열에 대한 다른 내용들은 추후에 다루겠음.\n- 마음의눈: a.f() 형태를 읽는 팁\n\na.f()는 f(a)로 생각하면 편리함.\na.f(2)는 f(a,2)로 생각하면 편리함.\n이런점에서 R %>% 연산자와 비슷하다고 생각할 수 있다. (약간 다르긴함)\n\n- 사실 .은 좀 더 다양한 상황에서 쓰일 수 있다. 변수이름.함수이름() 의 형태가 아니라\n\n패지키이름.함수이름()\n패키지이름.변수이름\n패키지이름.패키지이름.함수이름()\n…\n\n와 같이 다양한 형태가 가능하다. 근본적인 공통점은 .을 기준으로 상위개념.하위개념 으로 이해하는 것이 좋다."
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-13-2wk-1.html#len",
    "href": "posts/01_PythonBasic/2023-03-13-2wk-1.html#len",
    "title": "02wk-1: 파이썬의 자료형 (2)",
    "section": "len",
    "text": "len\n- len함수 소개: 원소의 갯수를 알려주는 함수.\n\na='ABCD' \nlen(a)\n\n4\n\n\n- 참고: len은 0차원 변수형에서는 동작하지 않고 1차원 변수형에서만 동작한다.\n(0차원) len 함수가 동작하지 않음.\n\na=3.14\n\n\nlen(a)\n\nTypeError: object of type 'float' has no len()\n\n\n\nb=True\n\n\nlen(b)\n\nTypeError: object of type 'bool' has no len()\n\n\n(1차원) len 함수가 잘 동작함.\n\na='3.14'\nlen(a)\n\n4\n\n\n\nb=[1,2,3]\n\n\nlen(b)\n\n3"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-27-4wk-1.html#인덱싱고급-스트라이딩",
    "href": "posts/01_PythonBasic/2023-03-27-4wk-1.html#인덱싱고급-스트라이딩",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "인덱싱고급 (스트라이딩)",
    "text": "인덱싱고급 (스트라이딩)\n- 스트라이딩 [start:end:step]\n\nlst = list('abcdefghijk')\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']\n\n\n\nlst[0:9:3]\n\n['a', 'd', 'g']\n\n\n- 생략\n\nlst[0:9]\n#lst[0:9:]\n#lst[0:9:1]\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']\n\n\n\nlst[0::3]\n\n['a', 'd', 'g', 'j']\n\n\n\nlst[:8:3]\n\n['a', 'd', 'g']\n\n\n- 예제1: 짝수/홀수 원소 추출\n아래와 같은 문자열이 있다고 하자.\n\nlst = list('abcdefghijk')\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']\n\n\nindex = 0,2,4, ... 에 해당하는 원소를 출력하라.\n\nlst[::2]\n\n['a', 'c', 'e', 'g', 'i', 'k']\n\n\nindex = 1,4,7 ... 에 해당하는 원소를 출력하라.\n\nlst[1::3]\n\n['b', 'e', 'h', 'k']\n\n\n- 예제2: 세로로..\n\n(예제2를 위한 예비학습) 문자열에서 \\n을 출력하면 출력시 줄바꿈이 일어난다.\n\nprint('1행\\n2행\\n3행')\n\n1행\n2행\n3행\n\n\n예비학습 끝\n\n아래와 같은 문자열이 있다고 하자.\n\ntxt = '너같이사랑스럽고\\n또예쁘고도멋지고\\n속훤히보이는너알\\n았어그동안고마웠\\n지정말정말사랑해'\nprint(txt)\n\n너같이사랑스럽고\n또예쁘고도멋지고\n속훤히보이는너알\n았어그동안고마웠\n지정말정말사랑해\n\n\n위 문자열을 세로로 읽는 코드를 작성하라. (9칸씩 점프하면서 읽으면 된다)\n(풀이)\n\ntxt[::9]\n\n'너또속았지'\n\n\n- step = -1 이면?\n\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']\n\n\n\nlst[::-1]\n\n['k', 'j', 'i', 'h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n- 스트라이딩으로 step = -1 옵션 주기 vs 리스트의 .reverse() 메소드 이용하기\n관찰1: reverse 메소드는 리스트 자체를 변화시킴\n\nlst = list('abcdefgh')\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n\nlst.reverse()  \nlst\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n관찰2: [::-1]는 리스트는 변화시키지 않음\n\nlst = list('abcdefgh')\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n\nlst[::-1]\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n- -step은 쓰기 까다롭다.\n(예제) 처음과 끝을 생략하지 않고 아래와 동일한 효과를 주는 코드를 만들어 보자.\n\nlst = list('abcdefgh')\nlst[::-1]\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n(풀이)\n결국 lst[?:?:-1]의 꼴에서 적당히 ?의 값을 채우면 된다. –> 어려워\n\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n\nlst[::-1]\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n\n\n\nNone\na\nb\nc\nd\ne\nf\ng\nh\nNone\n\n\n\n\n?\n0\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n-9\n-8\n-7\n-6\n-5\n-4\n-3\n-2\n-1\n?\n\n\n\n\nlst[-1:-9:-1] \n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-27-4wk-1.html#컴프리헨션-고급-if문이-포함된-컴프리헨션",
    "href": "posts/01_PythonBasic/2023-03-27-4wk-1.html#컴프리헨션-고급-if문이-포함된-컴프리헨션",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "컴프리헨션 고급 (if문이 포함된 컴프리헨션)",
    "text": "컴프리헨션 고급 (if문이 포함된 컴프리헨션)\n- 예제: 제곱수중에서 12로 나누어 떨어지는 수만 원소로 가지는 리스트를 만들고 싶다.\n\n제곱수: 1,4,9,16,25,36, …\n12로 나누어 떨어지는 수: 36, …\n\n(예비학습1)\n\n12 % 4 # %는 나머지를 계산하는 연산자, 12를 4로 나누면 나머지가 0\n\n0\n\n\n\n12 % 5 # %는 나머지를 계산하는 연산자, 12를 5로 나누면 나머지가 2\n\n2\n\n\n(예비학습2)\n\na = 2 ## a에 2를 \"대입\" 하라. \n\n\na == 2 # a에 들어있는 값이 2인지 \"test\"하라.\n\nTrue\n\n\n\na == 3 # a에 들어있는 값이 3인지 \"test\"하라.\n\nFalse\n\n\n(예비학습3) if문\n\na= 3 \nif a%2 == 0: \n    a_is='even' ## a%2==0 이 true일 경우만 실행된다. \nelse:\n    a_is='odd' ## a%2==0 이 false일 경우만 실행된다. \n\n\na,a_is\n\n(3, 'odd')\n\n\n(풀이1) - 비어있는 리스트를 만들고 \\(\\to\\) for문 + if문\n\nlst = list()\nfor i in range(1,101): \n    if i**2 % 12 == 0:\n        lst.append(i**2)\n\n\nlst\n\n[36,\n 144,\n 324,\n 576,\n 900,\n 1296,\n 1764,\n 2304,\n 2916,\n 3600,\n 4356,\n 5184,\n 6084,\n 7056,\n 8100,\n 9216]\n\n\n(풀이2) - if문이 포함된 리스트컴프리헨션\n\n[i**2 for i in range(1,101) if i**2 % 12 == 0]\n\n[36,\n 144,\n 324,\n 576,\n 900,\n 1296,\n 1764,\n 2304,\n 2916,\n 3600,\n 4356,\n 5184,\n 6084,\n 7056,\n 8100,\n 9216]"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-27-4wk-1.html#함수고급-if문이-포함된-리턴",
    "href": "posts/01_PythonBasic/2023-03-27-4wk-1.html#함수고급-if문이-포함된-리턴",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "함수고급 (if문이 포함된 리턴)",
    "text": "함수고급 (if문이 포함된 리턴)\n- 홀수/짝수를 판별하는 함수 만들기 1\n\ndef test(x): \n    if x % 2 == 0: \n        return 'even'\n    else:\n        return 'odd'\n\n\ntest(5)\n\n'odd'\n\n\n(사용)\n\n[test(l) for l in list(range(1,11))]\n\n['odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even']\n\n\n- 홀수/짝수를 판별하는 함수 만들기 2\n\ndef test(x):\n    return 'even' if x % 2 == 0 else 'odd'\n\n\ntest(4)\n\n'even'\n\n\n(사용)\n\n[test(l) for l in list(range(1,11))]\n\n['odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even']"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-27-4wk-1.html#len함수",
    "href": "posts/01_PythonBasic/2023-03-27-4wk-1.html#len함수",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "len함수",
    "text": "len함수\n- 0차원 자료형은 len함수가 동작하지 않음\n\na=1 \nlen(a)\n\nTypeError: object of type 'int' has no len()\n\n\n\na=True\nlen(a)\n\nTypeError: object of type 'bool' has no len()\n\n\n\na=3.14\nlen(a)\n\nTypeError: object of type 'float' has no len()\n\n\n\nnote: 이것이 어떠한 수학적인 의미를 가지거나 0차원의 본질적진리를 뜻하는 것은 안미. R에서는 1,3.14,TRUE의 길이가 1로 존재함.\n\n- 1차원 자료형은 len함수가 동작\n\na='guebin'\nlen(a)\n\n6\n\n\n\na=[1,2,3,4,5,6]\nlen(a)\n\n6\n\n\n\na=1,2,3,4,5,6 \nlen(a)\n\n6\n\n\n\na=range(10)\nlen(a)\n\n10\n\n\n- 길이가 1인 1차원 자료형과 0차원 자료형은 다른것임\n\na='g'\nlen(a)\n\n1\n\n\n\na=[1]\nlen(a)\n\n1\n\n\n\na=(1,)\nlen(a)\n\n1\n\n\n\na=range(1)\nlen(a)\n\n1\n\n\n- 길이가 0인 1차원 자료형도 존재함\n\na=''\nlen(a)\n\n0\n\n\n\na=[]\nlen(a)\n\n0\n\n\n\na=()\nlen(a)\n\n0\n\n\n\na=range(0)\nlen(a)\n\n0"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-27-4wk-1.html#intro-str-list-tuple-정리",
    "href": "posts/01_PythonBasic/2023-03-27-4wk-1.html#intro-str-list-tuple-정리",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "intro: str, list, tuple 정리",
    "text": "intro: str, list, tuple 정리\n- str, list, tuple은 모두 시퀀스형이라는 공통점이 있다. \\(\\to\\) 원소의 위치번호로 인덱싱이 가능\n\nlst = [1,2,3,4]\n\n\nlst[0] # 위치번호=0\n\n1\n\n\n\nlst[-1] # 위치번호=-1\n\n4\n\n\n- str, list, tuple은 차이점도 존재함. 잠깐 정리해보자.\n시퀀스형의 카테고리\n\n컨테니어형: list, tuple\n균일형: str\n가변형: list\n불변형: tuple, str\n\n표로 정리하면\n\n\n\n\n컨테니어형\n균일형\n\n\n\n\n가변형\nlist\n.\n\n\n불변형\ntuple\nstr\n\n\n\n- 시퀀스형이 아닌 1차원 자료형도 있을까? 원소의 위치번호로 인덱싱이 불가능한 자료형\n- 왜 이런게 필요할까?\n\n벡터에서 원소를 뽑는것은 정보의 모임에서 정보를 검색하는 것과 같다.\n정보를 순서대로 나열한뒤에 그 순서를 이용하여 검색하는 방법은 유용하다.\n하지만 경우에 따라서는 키워드를 기억해서 그 키워드를 바탕으로 정보에 접근하는 방법이 유용할 수 있다.\n\n카카오톡 대화내용검색\n(상황1) 오늘아침에 와이프가 뭔가를 카톡으로 부탁했었음. 그런데 그 뭔가가 기억안남.\n(상황2) 개강전에 동료교수와 함께 저녁약속을 카톡으로 잡았었음. 그런데 그게 언제인지 기억안남.\n(상황3) 오늘아침 동료교수와 함께 점심약속을 카톡으로 잡았었음. 그런데 그 장소가 기억나지 않음.\n- 순서대로 정리된 자료를 검색할때는 시퀀스형이 유리하다. 그런데 키워드로 검색하고 싶을 경우는 딕셔너리 타입이 유리하다."
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-27-4wk-1.html#선언",
    "href": "posts/01_PythonBasic/2023-03-27-4wk-1.html#선언",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "선언",
    "text": "선언\n- 방법1: 가장 일반적\n\ndct = {'guebin':49, 'hanni':80}\ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n- 방법2: dict() 이용\n\ndct = dict(guebin=49, hanni=80)\ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n- 방법3: 중첩된 리스트를 만든 뒤에 형태변환\n\n_lst = [['guebin',49],['hanni',80]]\n_lst \n\n[['guebin', 49], ['hanni', 80]]\n\n\n\ndict(_lst)\n\n{'guebin': 49, 'hanni': 80}\n\n\n- 방법4: 중첩된 튜플을 만든 뒤에 형태변환\n\n_tpl = ('guebin',49), ('hanni',80)\n_tpl\n\n(('guebin', 49), ('hanni', 80))\n\n\n\ndict(_tpl)\n\n{'guebin': 49, 'hanni': 80}"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-27-4wk-1.html#원소추출",
    "href": "posts/01_PythonBasic/2023-03-27-4wk-1.html#원소추출",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "원소추출",
    "text": "원소추출\n- 원소의 위치로 추출할 수 없고, key로 추출해야 한다.\n\ndct = {'guebin':49, 'hanni':80}\ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\nguebin의 점수를 추출하고 싶다면?\n\ndct['guebin']\n\n49\n\n\n- 만약에 dict가 아니라 list로 정보를 저장했다면?\n(예제) 아래와 같은 리스트에서 guebin의 점수를 추출하고 싶다면?\n\nlst=[['guebin',49],['hanni',80]]\nlst\n\n[['guebin', 49], ['hanni', 80]]\n\n\n(풀이1)\n\nlst[0][1] # guebin의 점수를 출력하란 의미\n\n49\n\n\n(풀이2) – 진짜 최악\n\n[lst[i][1] for i in range(len(lst)) if lst[i][0] == 'guebin']\n\n[49]\n\n\n(풀이3) – 덜 최악\n\n[score for name,score in lst if name == 'guebin']\n\n[49]\n\n\n- ’guebin’의 점수를 추출하는 코드 비교\n\ndct['guebin'] # 코드1: 단순하고, 가독성있음\n\n49\n\n\n\nlst[0][1] # 코드2: 단순하지만, 가독성이 있는건 아님\n\n49\n\n\n\n[lst[i][1] for i in range(len(lst)) if lst[i][0] =='guebin'] # 코드3: 단순하지도 않고, 가독성도 없음.\n\n[49]\n\n\n\n[score for name,score in lst if name=='guebin' ] # 코드4: 단순하지 않지만, 가독성은 있음\n\n[49]"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-27-4wk-1.html#원소추가-변경-삭제",
    "href": "posts/01_PythonBasic/2023-03-27-4wk-1.html#원소추가-변경-삭제",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "원소추가, 변경, 삭제",
    "text": "원소추가, 변경, 삭제\n\ndct={'guebin':49, 'hanni':80}\ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n- 원소에 접근: guebin의 점수 출력\n\ndct['guebin']\n\n49\n\n\n- 추가: hynn학생의 점수를 추가\n\ndct['hynn'] = 99\n\n\ndct\n\n{'guebin': 49, 'hanni': 80, 'hynn': 99}\n\n\n- 변경: hanni의 점수를 변경\n\ndct['hanni'] = 100 \n\n\ndct\n\n{'guebin': 49, 'hanni': 100, 'hynn': 99}\n\n\n- 삭제\n(방법1)\n\ndct={'guebin':49, 'hanni':80, 'hynn':99}\ndel dct['guebin']  \ndct\n\n{'hanni': 80, 'hynn': 99}\n\n\n(방법2)\n\ndct={'guebin':49, 'hanni':80, 'hynn':99} \ndct.pop('guebin')\n\n49\n\n\n\ndct\n\n{'hanni': 80, 'hynn': 99}\n\n\n- 참고로 리스트였다면 이러한 삭제작업역시 비효율적이었을 것임\n\nlst = [['guebin',49],['hanni',80],['hynn',99]] \nlst\n\n[['guebin', 49], ['hanni', 80], ['hynn', 99]]\n\n\nguebin의 점수를 삭제하려면?\n\n[[name,score] for name,score in lst if name != 'guebin']\n\n[['hanni', 80], ['hynn', 99]]"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-27-4wk-1.html#연산",
    "href": "posts/01_PythonBasic/2023-03-27-4wk-1.html#연산",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "연산",
    "text": "연산\n- 하나있어요..\n\ndct = {'guebin':49, 'hanni':80} \ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n\n'guebin' in dct\n\nTrue\n\n\n\n'hanni' in dct\n\nTrue\n\n\n\n'hynn' in dct\n\nFalse\n\n\n- in은 사실 다른자료형도 가능했음\n(관찰1)\n\n'a' in 'guebin' \n\nFalse\n\n\n\n'b' in 'guebin' \n\nTrue\n\n\n\n'c' in 'guebin' \n\nFalse\n\n\n(관찰2)\n\ntpl = 1,2,3 \ntpl\n\n(1, 2, 3)\n\n\n\n1 in tpl\n\nTrue\n\n\n\n4 in tpl\n\nFalse\n\n\n(관찰3)\n\nlst = [['guebin',49],['hanni',80],['hynn',99]] \nlst\n\n[['guebin', 49], ['hanni', 80], ['hynn', 99]]\n\n\n\n['guebin',49] in lst\n\nTrue\n\n\n- in연산자가 dict형에 사용되면 key를 기준으로 True, False를 판단한다."
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-27-4wk-1.html#딕셔너리-특수기능",
    "href": "posts/01_PythonBasic/2023-03-27-4wk-1.html#딕셔너리-특수기능",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "딕셔너리 특수기능",
    "text": "딕셔너리 특수기능\n(pop)\n\ndct = {'guebin':49, 'hanni':80} \ndct.pop('hanni')\ndct\n\n{'guebin': 49}\n\n\n(get)\n\ndct = {'guebin':49, 'hanni':80} \ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n\ndct.get('guebin') \n\n49\n\n\n아래와 같은 기능\n\ndct['guebin']\n\n49\n\n\n미묘한 차이점이 존재함\n\ndct['hynn'] # hynn이 없어서 키에러 출력, 그런 key는 없다.. \n\nKeyError: 'hynn'\n\n\n\ndct.get('hynn') # hynn이 없으면 아무것도 출력안함 \n\n(keys,values,items)\n- .keys()는 딕셔너리의 키를 리턴한다.\n\ndct = {'guebin':49, 'hanni':80} \ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n\n_keys=dct.keys()\n_keys\n\ndict_keys(['guebin', 'hanni'])\n\n\n\ntype(_keys) # 리턴된 자료형은 이상한것임\n\ndict_keys\n\n\n\nlist(_keys) # 아무튼 그 이상한 자료형도 리스트화 가능 \n\n['guebin', 'hanni']\n\n\n- .values()는 딕셔너리의 값들을 리턴한다.\n\n_values = dct.values()\n_values \n\ndict_values([49, 80])\n\n\n\ntype(_values)\n\ndict_values\n\n\n\nlist(_values)\n\n[49, 80]\n\n\n- .items()는 딕셔너리의 (키,값)을 리턴한다.\n\n_items = dct.items()\n_items \n\ndict_items([('guebin', 49), ('hanni', 80)])\n\n\n\ntype(_items)\n\ndict_items\n\n\n\nlist(_items)\n\n[('guebin', 49), ('hanni', 80)]"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-27-4wk-1.html#for문과-dict-star",
    "href": "posts/01_PythonBasic/2023-03-27-4wk-1.html#for문과-dict-star",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "for문과 dict (\\(\\star\\))",
    "text": "for문과 dict (\\(\\star\\))\n\ndct = {'guebin': 49, 'hanni': 80}\ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n(예시1)\n\nfor k in dct.keys():\n    print(k)\n\nguebin\nhanni\n\n\n\nfor k in dct:\n    print(k)\n\nguebin\nhanni\n\n\n\n딕셔너리 그자체도 for문에 넣을 수 있다.\nk에는 value가 삭제되어 들어간다. (즉 key만)\n결과를 보면 dct 대신에 dct.keys()와 list(dct)를 넣었을때와 결과가 같다.\n\n\nNote: list(dct) 하면 key만 리턴된다.\n\n(예시2)\n\nfor v in dct.values():\n    print(v)\n\n49\n80\n\n\n(예시3)\n\nfor i in dct.items():\n    print(i)\n\n('guebin', 49)\n('hanni', 80)\n\n\n(예시4)\n\nfor k,v in dct.items():\n    print(k,v)\n\nguebin 49\nhanni 80\n\n\n(예시5) – {}의 중간고사 점수는 {}점 입니다.\n\nfor name,score in dct.items():\n    print('{}의 중간고사 점수는 {}점 입니다.'.format(name,score))\n\nguebin의 중간고사 점수는 49점 입니다.\nhanni의 중간고사 점수는 80점 입니다."
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-27-4wk-1.html#dict에서-key혹은-value만-뽑아내기",
    "href": "posts/01_PythonBasic/2023-03-27-4wk-1.html#dict에서-key혹은-value만-뽑아내기",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "dict에서 key혹은 value만 뽑아내기",
    "text": "dict에서 key혹은 value만 뽑아내기\n- 예제: 아래의 dict에서 key만 뽑아내고 싶다.\n\ndct = {'guebin':49, 'hanni':80} \n\n(풀이1)\n\nlist(dct)\n\n['guebin', 'hanni']\n\n\n(풀이2)\n\nlist(dct.keys())\n\n['guebin', 'hanni']\n\n\n(풀이3)\n\n[k for k in dct]\n\n['guebin', 'hanni']\n\n\n(풀이4)\n\n[k for k,v in dct.items()]\n\n['guebin', 'hanni']\n\n\n- 예제: 아래의 dict에서 value만 뽑아내고 싶다.\n\ndct = {'guebin':49, 'hanni':80} \n\n(풀이1)\n\nlist(dct.values())\n\n[49, 80]\n\n\n(풀이2)\n\n[dct[k] for k in dct]\n\n[49, 80]\n\n\n(풀이3)\n\n[v for v in dct.values()]\n\n[49, 80]\n\n\n(풀이4)\n\n[v for k,v in dct.items()]\n\n[49, 80]"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-27-4wk-1.html#바꿔치기-1",
    "href": "posts/01_PythonBasic/2023-03-27-4wk-1.html#바꿔치기-1",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "바꿔치기 (1)",
    "text": "바꿔치기 (1)\n- 예제1: 아래와 같은 리스트가 있다고 하자.\n\nlst = list('abcd'*2)\nlst\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd']\n\n\n아래의 규칙에 의하여 lst의 각 원소의 값을 바꾸고 싶다고 하자. 이를 구현하는 코드를 작성하라.\n\n\n\n변환전\n변환후\n\n\n\n\n‘a’\n[1,0,0,0]\n\n\n‘b’\n[0,1,0,0]\n\n\n‘c’\n[0,0,1,0]\n\n\n‘d’\n[0,0,0,1]\n\n\n\nhint: 아래의 dct를 이용할 것\n\nlst = list('abcd'*2)\nlst\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd']\n\n\n\ndct = {'a':[1,0,0,0], 'b':[0,1,0,0], 'c':[0,0,1,0], 'd':[0,0,0,1]}\ndct\n\n{'a': [1, 0, 0, 0], 'b': [0, 1, 0, 0], 'c': [0, 0, 1, 0], 'd': [0, 0, 0, 1]}\n\n\n(풀이)\n\n[dct[x] for x in lst]\n\n[[1, 0, 0, 0],\n [0, 1, 0, 0],\n [0, 0, 1, 0],\n [0, 0, 0, 1],\n [1, 0, 0, 0],\n [0, 1, 0, 0],\n [0, 0, 1, 0],\n [0, 0, 0, 1]]\n\n\n- 예제2: 예제1을 역변환하라.\n\ndct = {'a':[1,0,0,0], 'b':[0,1,0,0], 'c':[0,0,1,0], 'd':[0,0,0,1]}\n\n\nlst= [[1, 0, 0, 0],\n      [0, 1, 0, 0],\n      [0, 0, 1, 0],\n      [0, 0, 0, 1],\n      [1, 0, 0, 0],\n      [0, 1, 0, 0],\n      [0, 0, 1, 0],\n      [0, 0, 0, 1]]\nlst \n\n[[1, 0, 0, 0],\n [0, 1, 0, 0],\n [0, 0, 1, 0],\n [0, 0, 0, 1],\n [1, 0, 0, 0],\n [0, 1, 0, 0],\n [0, 0, 1, 0],\n [0, 0, 0, 1]]\n\n\n(풀이)\n\n[x for l in lst for x,y in dct.items() if y == l]\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd']"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-27-4wk-1.html#바꿔치기-2",
    "href": "posts/01_PythonBasic/2023-03-27-4wk-1.html#바꿔치기-2",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "바꿔치기 (2)",
    "text": "바꿔치기 (2)\n- 예제1: 아래와 같은 리스트를 고려하자.\n\nlst = ['딸기','사과','바나나','딸기','사과','오토바이','자동차','버스','기차','오토바이','자동차']\n\n다음의 맵핑규칙에 따라서 위의 리스트의 원소를 바꾸어라.\n\n\n\n변환전\n변환후\n\n\n\n\n딸기\n과일\n\n\n사과\n과일\n\n\n바나나\n과일\n\n\n오토바이\n탈것\n\n\n자동차\n탈것\n\n\n버스\n탈것\n\n\n기차\n탈것\n\n\n\n(풀이)\n\ndct = {'과일':['딸기','사과','바나나'], '탈것':['오토바이','자동차','버스','기차']}\ndct\n\n{'과일': ['딸기', '사과', '바나나'], '탈것': ['오토바이', '자동차', '버스', '기차']}\n\n\n\n[x for l in lst for x,y in dct.items() if l in y]\n\n['과일', '과일', '과일', '과일', '과일', '탈것', '탈것', '탈것', '탈것', '탈것', '탈것']"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-04-05-5wk-2.html#해결1",
    "href": "posts/01_PythonBasic/2023-04-05-5wk-2.html#해결1",
    "title": "05wk-2: 모듈, 패키지, 라이브러리",
    "section": "해결1",
    "text": "해결1\n- 자주 사용하는 함수를 myfuns.py에 저장한다.\n# myfuns.py\ndef vec2_add(a,b): \n    return [a[0]+b[0], a[1]+b[1]]\n- %run myfuns를 실행\n준비: “00” -> 커널재시작\n\n%run myfuns \n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-04-05-5wk-2.html#해결2",
    "href": "posts/01_PythonBasic/2023-04-05-5wk-2.html#해결2",
    "title": "05wk-2: 모듈, 패키지, 라이브러리",
    "section": "해결2",
    "text": "해결2\n- 자주 사용하는 함수를 myfuns.py에 저장한다.\n# myfuns.py\ndef vec2_add(a,b): \n    return [a[0]+b[0], a[1]+b[1]]\n- import myfuns를 이용\n(준비) “00” -> 커널재시작\n\nimport myfuns \n\n\na=[1,2]\nb=[3,4]\nmyfuns.vec2_add(a,b)\n\n[4, 6]"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-04-05-5wk-2.html#사용방법",
    "href": "posts/01_PythonBasic/2023-04-05-5wk-2.html#사용방법",
    "title": "05wk-2: 모듈, 패키지, 라이브러리",
    "section": "사용방법",
    "text": "사용방법\n- 사용방법1\n준비: “00” -> 커널재시작\n\nimport myfuns \n\n\nmyfuns.vec2_add([1,2],[3,4]) \n\n[4, 6]\n\n\n\nmyfuns.vec2_add 의 의미: myfuns.py 라는 파일안에 vec2_add라는 함수가 있음. 그것을 실행하라.\n.의 의미: 상위.하위의 개념!\n\n(주의) 아래와 같이 사용불가능 하다.\n\nvec2_add([1,2],[3,4])\n\nNameError: name 'vec2_add' is not defined\n\n\n- 사용방법2\n준비: “00” -> 커널재시작\n\nfrom myfuns import vec2_add \n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n(주의) 이 경우는 오히려 아래가 불가능함\n\nmyfuns.vec2_add([1,2],[3,4]) # myfuns안의 vec2_add만 임포트했지 myfuns자체를 임포트 한것은 아님 \n\nNameError: name 'myfuns' is not defined\n\n\n- 사용방법3\n준비: “00” -> 커널재시작\n\nimport myfuns\nfrom myfuns import vec2_add\n\n\nmyfuns.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n- 사용방법4\n준비: “00” -> 커널재시작\n\nfrom myfuns import vec2_add, vec2_sub \n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nvec2_sub([1,2],[3,4])\n\n[-2, -2]\n\n\n- 사용방법5\n준비: “00” -> 커널재시작\n\nfrom myfuns import * #*는 all의 의미 \n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nvec2_sub([1,2],[3,4])\n\n[-2, -2]\n\n\n- 사용방법6\n준비: “00” -> 커널재시작\n\nimport myfuns as mf \n\n\nmf.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nmf.vec2_sub([1,2],[3,4])\n\n[-2, -2]\n\n\n(오히려 아래는 실행불가능)\n\nmyfuns.vec2_add([1,2],[3,4])\n\nNameError: name 'myfuns' is not defined\n\n\n\nmyfuns.vec2_sub([1,2],[3,4])\n\nNameError: name 'myfuns' is not defined\n\n\n- 잘못된 사용방법1\n준비: “00” -> 커널재시작\n\nimport myfuns as mf \nfrom mf import vec2_add \n\nModuleNotFoundError: No module named 'mf'\n\n\n- 사용방법7\n준비: “00” -> 커널재시작\n\nimport myfuns as mf \nfrom myfuns import vec2_add \n\n\nmf.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n- 사용방법8\n준비: “00” -> 커널재시작\n\nimport myfuns as mf \nfrom myfuns import vec2_add as add \n\n\nmf.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nvec2_add([1,2],[3,4])\n\nNameError: name 'vec2_add' is not defined\n\n\n\nadd([1,2],[3,4])\n\n[4, 6]"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-04-05-5wk-2.html#도움말-작성기능",
    "href": "posts/01_PythonBasic/2023-04-05-5wk-2.html#도움말-작성기능",
    "title": "05wk-2: 모듈, 패키지, 라이브러리",
    "section": "도움말 작성기능",
    "text": "도움말 작성기능\n- mf란 무엇인가?\n준비: “00” -> 커널재시작\n\nimport myfuns as mf \n\n\nmf\n\n<module 'myfuns' from '/home/cgb3/Dropbox/07_lectures/IP2022/_notebooks/myfuns.py'>\n\n\n\nmf?\n\n\nType:        module\nString form: <module 'myfuns' from '/home/cgb3/Dropbox/07_lectures/IP2022/_notebooks/myfuns.py'>\nFile:        ~/Dropbox/07_lectures/IP2022/_notebooks/myfuns.py\nDocstring:   <no docstring>\n\n\n\n\n\ntype(mf)\n\nmodule\n\n\n\nmf의 타입은 모듈이라고 나옴, 현재 단계에서는 무엇인지 알기 어려움\n\n- Docstring의 내용을 채울 수 있을까?\n준비1: myfuns.py 파일을 아래와 같이 수정한다.\n준비2: “00” -> 커널재시작\n\nimport myfuns as mf \n\n\nmf?\n\n\nType:        module\nString form: <module 'myfuns' from '/home/cgb3/Dropbox/07_lectures/IP2022/_notebooks/myfuns.py'>\nFile:        ~/Dropbox/07_lectures/IP2022/_notebooks/myfuns.py\nDocstring:   이것은 길이가 2인 벡터의 합 혹은 차를 구하는 모듈입니다."
  },
  {
    "objectID": "posts/01_PythonBasic/2023-04-05-5wk-2.html#주의점",
    "href": "posts/01_PythonBasic/2023-04-05-5wk-2.html#주의점",
    "title": "05wk-2: 모듈, 패키지, 라이브러리",
    "section": "주의점",
    "text": "주의점\n- myfuns.py는 최초 한번만 import 된다.\n준비: “00” -> 커널재시작\n\nimport myfuns\n\n\nmyfuns.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\nmyfuns.py파일을 열고 함수를 아래와 같이 바꾸자.\n\"\"\"이것은 길이가 2인 벡터의 합 혹은 차를 구하는 모듈입니다.\"\"\" \ndef vec2_add(a,b): \n    print(\"이것은 myfuns.py에 정의된 함수입니다\") \n    return [a[0]+b[0], a[1]+b[1]]\ndef vec2_sub(a,b): \n    return [a[0]-b[0], a[1]-b[1]]\n다시 myfuns를 로드하고 myfuns.vec2_add 를 실행하여 보자.\n\nimport myfuns\n\n\nmyfuns.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n바뀐내용이 적용되지 않는다.\n커널을 다시 시작하고 임포트해보자.\n“00” -> 커널재시작\n\nimport myfuns\n\n\nmyfuns.vec2_add([1,2],[3,4])\n\n이것은 myfuns.py에 정의된 함수입니다\n\n\n[4, 6]\n\n\n- myfuns.py는 주피터노트북파일과 같은 폴더에 존재해야 한다.\n준비1: “00” -> 커널재시작\n준비2: myfuns.py을 복사하여 다른 폴더로 이동. 예를들면 IP0403 폴더를 만들고 그 폴더안에 myfuns.py파일을 복사해서 붙여넣은뒤에 파일이름을 myfuns2.py 로 변경.\n\nimport myfuns # 주피터노트북파일과 같은 폴더에 있는 myfuns는 잘 로드되지만 \n\n\nimport myfuns2 # 주피터노트북파일과 다른 폴더에 있는 myfuns2는 그렇지 않다. \n\nModuleNotFoundError: No module named 'myfuns2'\n\n\n- IP0403 폴더에 있는 myfuns2.py를 실행하기 위해서는 아래와 같이 할 수 있다.\n준비: “00” -> 커널재시작\n\nfrom IP0403 import myfuns2\n\n\nmyfuns2.vec2_add([1,2],[3,4]) \n\n이것은 myfuns2.py에 정의된 함수입니다\n\n\n[4, 6]\n\n\n- 아래도 가능하다.\n준비: “00” -> 커널재시작\n\nfrom IP0403.myfuns2 import vec2_add as add \n\n\nadd([1,2],[3,4])\n\n이것은 myfuns2.py에 정의된 함수입니다\n\n\n[4, 6]\n\n\n참고로 아래는 모두 정의되지 않음\n\nIP0403.myfuns2.vec2_add([1,2],[3,4]) \n\nNameError: name 'IP0403' is not defined\n\n\n\nmyfuns2.vec2_add([1,2],[3,4]) \n\nNameError: name 'myfuns2' is not defined\n\n\n\nvec2_add([1,2],[3,4]) \n\nNameError: name 'vec2_add' is not defined"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-04-05-5wk-2.html#폴더와-함께-사용할시",
    "href": "posts/01_PythonBasic/2023-04-05-5wk-2.html#폴더와-함께-사용할시",
    "title": "05wk-2: 모듈, 패키지, 라이브러리",
    "section": "폴더와 함께 사용할시",
    "text": "폴더와 함께 사용할시\n- 언뜻 생각하면 아래가 가능할 것 같다.\nimport IP0403 \nIP0403.myfuns2.vec2_add([1,2],[3,4]) \n- 하지만 불가능하다.\n준비: “00” -> 커널재시작\n\nimport IP0403 \n\n\n되는거아냐?\n\n\nIP0403.myfuns2.vec2_add([1,2],[3,4])\n\nAttributeError: module 'IP0403' has no attribute 'myfuns2'\n\n\n\n여기서 불가능하다.\n\n- (암기) IP0403 폴더안에 __init__.py라는 파일을 만들고 내용에 아래와 같이 쓰면 가능하다.\n# ./IP0403/__init__.py \nfrom . import myfuns2\n준비1: 위의 지침을 따른다.\n준비2: “00” -> 커널재시작\n\nimport IP0403 \n\n\nIP0403.myfuns2.vec2_add([1,2],[3,4])\n\n이것은 myfuns2.py에 정의된 함수입니다\n\n\n[4, 6]\n\n\n컴퓨터 상식 - .: 현재폴더를 의미 - ..: 상위폴더를 의미 - ./myfuns.py: 현재폴더안에 있는 myfuns.py를 의미 - ./IP0403/myfuns2.py: 현재폴더만에 IP0403폴더안의 myfuns2.py 파일을 의미 - ../myfuns.py: 현재폴더보다 한단계상위폴더에 있는 myfuns.py를 의미 - cd ./IP0403: 현재폴더안에 있는 IP0403폴더로 이동해라. (cd IP0403으로 줄여쓸 수 있음) - cd .. 현재폴더보다 한단계 상위폴더로 이동하라.\n따라서 from . import myfuns2는 현재폴더에서 myfuns2를 찾아서 임포트 하라는 의미로 해석가능\n- 의미상으로 보면 아래가 실행가능할듯 한데 불가능하다.\n\n#import myfuns\nfrom . import myfuns\n\nImportError: attempted relative import with no known parent package"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-04-05-5wk-2.html#site-packages-실습금지",
    "href": "posts/01_PythonBasic/2023-04-05-5wk-2.html#site-packages-실습금지",
    "title": "05wk-2: 모듈, 패키지, 라이브러리",
    "section": "site-packages (실습금지)",
    "text": "site-packages (실습금지)\n- 의문: 왜 현재폴더에 numpy.py라든가 numpy라는 이름의 폴더가 없는데도 import 가능한지?\n준비: “00” -> 커널재시작\n\nimport numpy as np\n\n\nimport IP0403 as ip \n\n\nip?\n\n\nType:        module\nString form: <module 'IP0403' from '/home/cgb3/Dropbox/07_lectures/IP2022/_notebooks/IP0403/__init__.py'>\nFile:        ~/Dropbox/07_lectures/IP2022/_notebooks/IP0403/__init__.py\nDocstring:   <no docstring>\n\n\n\n\n\nnp?\n\n\nType:        module\nString form: <module 'numpy' from '/home/cgb3/anaconda3/envs/py310/lib/python3.10/site-packages/numpy/__init__.py'>\nFile:        ~/anaconda3/envs/py310/lib/python3.10/site-packages/numpy/__init__.py\nDocstring:  \nNumPy\n=====\nProvides\n  1. An array object of arbitrary homogeneous items\n  2. Fast mathematical operations over arrays\n  3. Linear Algebra, Fourier Transforms, Random Number Generation\nHow to use the documentation\n----------------------------\nDocumentation is available in two forms: docstrings provided\nwith the code, and a loose standing reference guide, available from\n`the NumPy homepage <https://www.scipy.org>`_.\nWe recommend exploring the docstrings using\n`IPython <https://ipython.org>`_, an advanced Python shell with\nTAB-completion and introspection capabilities.  See below for further\ninstructions.\nThe docstring examples assume that `numpy` has been imported as `np`::\n  >>> import numpy as np\nCode snippets are indicated by three greater-than signs::\n  >>> x = 42\n  >>> x = x + 1\nUse the built-in ``help`` function to view a function's docstring::\n  >>> help(np.sort)\n  ... # doctest: +SKIP\nFor some objects, ``np.info(obj)`` may provide additional help.  This is\nparticularly true if you see the line \"Help on ufunc object:\" at the top\nof the help() page.  Ufuncs are implemented in C, not Python, for speed.\nThe native Python help() does not know how to view their help, but our\nnp.info() function does.\nTo search for documents containing a keyword, do::\n  >>> np.lookfor('keyword')\n  ... # doctest: +SKIP\nGeneral-purpose documents like a glossary and help on the basic concepts\nof numpy are available under the ``doc`` sub-module::\n  >>> from numpy import doc\n  >>> help(doc)\n  ... # doctest: +SKIP\nAvailable subpackages\n---------------------\ndoc\n    Topical documentation on broadcasting, indexing, etc.\nlib\n    Basic functions used by several sub-packages.\nrandom\n    Core Random Tools\nlinalg\n    Core Linear Algebra Tools\nfft\n    Core FFT routines\npolynomial\n    Polynomial tools\ntesting\n    NumPy testing tools\nf2py\n    Fortran to Python Interface Generator.\ndistutils\n    Enhancements to distutils with support for\n    Fortran compilers support and more.\nUtilities\n---------\ntest\n    Run numpy unittests\nshow_config\n    Show numpy build configuration\ndual\n    Overwrite certain functions with high-performance SciPy tools.\n    Note: `numpy.dual` is deprecated.  Use the functions from NumPy or Scipy\n    directly instead of importing them from `numpy.dual`.\nmatlib\n    Make everything matrices.\n__version__\n    NumPy version string\nViewing documentation using IPython\n-----------------------------------\nStart IPython with the NumPy profile (``ipython -p numpy``), which will\nimport `numpy` under the alias `np`.  Then, use the ``cpaste`` command to\npaste examples into the shell.  To see which functions are available in\n`numpy`, type ``np.<TAB>`` (where ``<TAB>`` refers to the TAB key), or use\n``np.*cos*?<ENTER>`` (where ``<ENTER>`` refers to the ENTER key) to narrow\ndown the list.  To view the docstring for a function, use\n``np.cos?<ENTER>`` (to view the docstring) and ``np.cos??<ENTER>`` (to view\nthe source code).\nCopies vs. in-place operation\n-----------------------------\nMost of the functions in `numpy` return a copy of the array argument\n(e.g., `np.sort`).  In-place versions of these functions are often\navailable as array methods, i.e. ``x = np.array([1,2,3]); x.sort()``.\nExceptions to this rule are documented.\n\n\n\n\n- 추측: ~/anaconda3/envs/py310/lib/python3.10/site-packages/를 찾아가보자. 그곳에 numpy폴더가 있을 것이다.\n\n!ls ~/anaconda3/envs/py310/lib/python3.10/site-packages | grep numpy\n\nnumpy\nnumpy-1.22.2.dist-info\n\n\n- 추측2: ~/anaconda3/envs/py310/lib/python3.10/site-packages/에 내가 자주 쓰는 기능을 폴더로 만들어서 모아두면 어디서든지 import 할 수 있다.\n\n!mkdir ~/anaconda3/envs/py310/lib/python3.10/site-packages/guebin # guebin 폴더 생성 \n\n\n!cp ./myfuns.py ~/anaconda3/envs/py310/lib/python3.10/site-packages/guebin \n# 현폴더에 있는 myfuns.py를 아까만든 guebin 폴더로 복사 \n\n\nfrom guebin import myfuns\n\n\nmyfuns?\n\n\nType:        module\nString form: <module 'guebin.myfuns' from '/home/cgb3/anaconda3/envs/py310/lib/python3.10/site-packages/guebin/myfuns.py'>\nFile:        ~/anaconda3/envs/py310/lib/python3.10/site-packages/guebin/myfuns.py\nDocstring:   이것은 길이가 2인 벡터의 합 혹은 차를 구하는 모듈입니다.\n\n\n\n\n\n!rm  ~/anaconda3/envs/py310/lib/python3.10/site-packages/guebin -rf # guebin 폴더삭제 \n\n- 추측3: guebin이 사라진 상태에서는 from guebin import myfuns 이 동작하지 않을 것이다.\n준비: “00” -> 커널재시작\n\nfrom guebin import myfuns\n\nModuleNotFoundError: No module named 'guebin'\n\n\n- 추측4: ~/anaconda3/envs/py310/lib/python3.10/site-packages/에서 numpy를 지운다면 numpy를 import할 수 없다.\n준비: “00” -> 커널재시작\n\nimport numpy as np\n\nModuleNotFoundError: No module named 'numpy'\n\n\n- 추측5: !pip install numpy를 하면 다시 폴더가 생길 것이다.\n\n!pip uninstall numpy -y \n\nFound existing installation: numpy 1.22.2\nUninstalling numpy-1.22.2:\n  Successfully uninstalled numpy-1.22.2\n\n\n\n!pip install numpy \n\nCollecting numpy\n  Downloading numpy-1.22.3-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (16.8 MB)\n     |████████████████████████████████| 16.8 MB 11.4 MB/s eta 0:00:01\nInstalling collected packages: numpy\nSuccessfully installed numpy-1.22.3"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-04-03-5wk-1.html#개발환경-구축방법이-많은-이유",
    "href": "posts/01_PythonBasic/2023-04-03-5wk-1.html#개발환경-구축방법이-많은-이유",
    "title": "05wk-1: 개발환경의 변화",
    "section": "개발환경 구축방법이 많은 이유?",
    "text": "개발환경 구축방법이 많은 이유?\n- 파이썬 개발환경 구축은 수많은 방법이 있다.\n- 이는 마치 라면의 레시피를 검색하면 수많은 방법이 나오는것과 유사함.\n\n방법1: 스프를 먼저 넣고 끓인다음 라면을 넣어야 합니다.\n방법2: 양은냄비에 물넣고 물이 끊으면 라면과 스프를 같이 넣고 마지막에 계란을 넣는다.\n방법3: 먹다남은 삼겹살을 후라이팬에 볶은다음에 물을 붓고 라면을 넣는다.\n방법4: 용기에 라면+스프+뜨거운물 랩을 씌운뒤에 젓가락으로 구멍을 뚫고 전자렌지에 돌린다.\n…\n\n- 우리는 모든 방법을 나열할 순 없지만 모든 방법을 이해할 수 있다. 왜냐하면 라면을 끓이는 공통적인 맥락을 우리는 알고 있으니까\n- 파이썬을 설치하는 다양한 방법 역시 공통맥락을 파악하면 이해하기 쉽다.\n- 저의 목적: 파이썬을 설치하고 실행하는 공통맥락을 설명하고 싶음\n- 설치하는 방법이 다양한 이유? 파이썬이 인기있음 + 다양한 방법을 설치를 하면 각자의 장점이 뚜렷해서"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-04-03-5wk-1.html#python",
    "href": "posts/01_PythonBasic/2023-04-03-5wk-1.html#python",
    "title": "05wk-1: 개발환경의 변화",
    "section": "python",
    "text": "python\n- 윈도우에서 anaconda prompt 실행 -> python\n(base) C:\\Users\\python>python\nPython 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> [1,2,3]+[4]\n[1, 2, 3, 4]\n>>> a=[1,2,3]+[4]\n>>> a\n[1, 2, 3, 4]\n- 2개를 실행할 수도 있음. (두 환경은 각각 서로 독립적인 파이썬, 변수가 공유되지 않음) \\(\\star\\)\n- 아쉬운점: `?list’와 같이 도움말 기능이 동작하지 않음\n>>> ?list\n  File \"<stdin>\", line 1\n    ?list\n    ^\nSyntaxError: invalid syntax\n>>>"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-04-03-5wk-1.html#ipython",
    "href": "posts/01_PythonBasic/2023-04-03-5wk-1.html#ipython",
    "title": "05wk-1: 개발환경의 변화",
    "section": "ipython",
    "text": "ipython\n- 윈도우에서 anaconda prompt 실행 -> ipython\n(base) C:\\Users\\python>ipython\nPython 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)]\nType 'copyright', 'credits' or 'license' for more information\nIPython 7.29.0 -- An enhanced Interactive Python. Type '?' for help.\n\nIn [1]: a=[1,2,3]\n\nIn [2]: a\nOut[2]: [1, 2, 3]\n\nIn [3]: a+[4]\nOut[3]: [1, 2, 3, 4]\n- ?list가 가능\nIn [4]: ?list\nInit signature: list(iterable=(), /)\nDocstring:\nBuilt-in mutable sequence.\n\nIf no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.\nType:           type\nSubclasses:     _HashedSeq, StackSummary, DeferredConfigList, SList, _ImmutableLineList, FormattedText, NodeList, _ExplodedList, Stack, _Accumulator, ...\n\n- 색깔이 알록달록해서 문법을 보기 편하다. (구문강조)"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-04-03-5wk-1.html#세대-프로그래머의-삶-with-python",
    "href": "posts/01_PythonBasic/2023-04-03-5wk-1.html#세대-프로그래머의-삶-with-python",
    "title": "05wk-1: 개발환경의 변화",
    "section": "1세대 프로그래머의 삶 with python",
    "text": "1세대 프로그래머의 삶 with python\n- 1부터 10까지 합을 구하는 프로그램을 만들고 싶음\n- 시도1: python을 키고 아래와 같이 실행\n(base) C:\\Users\\python>python\nPython 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> total = 0\n>>> for i in range(10):\n...     total=total+i\n...\n>>> total\n45\n>>>\n- 반성: 정답은 55인데 45가 출력되었다! \\(\\to\\) range(10)을 range(1,11)으로 바꿔야겠다!\n- 시도2: range(1,11)을 바꿔야겠다고 생각하고 다시 입력하다가 오타가 발생\n>>> total =0\n>>> for i in range(1,11):\n...     total = totla +i\n...\n\n앗 totla이라고 잘못쳤다.\n\n- 반성: 다음에는 정신을 똑바로 차려야겠다.\n- 불편한점: … 다.."
  },
  {
    "objectID": "posts/01_PythonBasic/2023-04-03-5wk-1.html#세대-프로그래머의-삶-with-ipython",
    "href": "posts/01_PythonBasic/2023-04-03-5wk-1.html#세대-프로그래머의-삶-with-ipython",
    "title": "05wk-1: 개발환경의 변화",
    "section": "1세대 프로그래머의 삶 with ipython",
    "text": "1세대 프로그래머의 삶 with ipython\n- ipython을 사용한 프로그래머는 좀 더 상황이 낫다\n(base) C:\\Users\\python>ipython\nPython 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)]\nType 'copyright', 'credits' or 'license' for more information\nIPython 7.29.0 -- An enhanced Interactive Python. Type '?' for help.\n\nIn [1]: total = 0\n\nIn [2]: for i in range(1,11):\n   ...:     total = total + i\n   ...:\n\nIn [3]: total\nOut[3]: 55\n\n편한점1: 자동으로 들여쓰기가 되어서 편함\n편한점2: 화살표를 이용해서 for문을 쓰는 도중에 위아래로 이동가능\n불편한점1: 화살표로 이동할수는 있는데 마우스로는 이동할 수 없다.\n불편한점2: 내가 작성한 코드를 관리하기 어렵다."
  },
  {
    "objectID": "posts/01_PythonBasic/2023-04-03-5wk-1.html#모델1-원격컴퓨터",
    "href": "posts/01_PythonBasic/2023-04-03-5wk-1.html#모델1-원격컴퓨터",
    "title": "05wk-1: 개발환경의 변화",
    "section": "모델1: 원격컴퓨터",
    "text": "모델1: 원격컴퓨터\n- 준비상태\n\n전북대컴퓨터: ipython을 실행 + 이 컴퓨터는 인터넷 연결이 되어있어야함\n우리집노트북: 크롬실행 + 이 컴퓨터도 인터넷이 연결되어 있어야함\n\n- 명령입력\n\n우리집노트북 크롬에서 1+1을 입력하고 쉬프트 엔터를 누름\n\n- 우리집노트북 -> 전북대컴퓨터\n\n우리집 노트북의 내부의 어떤프로그램은 1+1이라는 명령을 복사하여 카카오톡으로 전북대 컴퓨터에 전달\n전북대 컴퓨터의 내부의 어떤프로그램은 1+1이라는 명령을 카톡으로 받아서 그것을 ipython에게 전달\n\n- 전북대컴퓨터 -> 우리집노트북\n\n전북대컴퓨터 내부의 ipython은 2라는 출력결과를 계산함\n전북대컴퓨터 내부의 어떤프로그램은 계산결과를 카톡으로 우리집 노트북에 알려줌\n나는 우리집 노트북에서 계산결과를 받아볼 수 있다."
  },
  {
    "objectID": "posts/01_PythonBasic/2023-04-03-5wk-1.html#모델2-원격컴퓨터-가상컴퓨터",
    "href": "posts/01_PythonBasic/2023-04-03-5wk-1.html#모델2-원격컴퓨터-가상컴퓨터",
    "title": "05wk-1: 개발환경의 변화",
    "section": "모델2: 원격컴퓨터 + 가상컴퓨터",
    "text": "모델2: 원격컴퓨터 + 가상컴퓨터\n- 준비상태\n\n성능좋은 전북대 컴퓨터 1개\n내 노트북 1개 (그냥 싸고 가벼운거)\n대학원생 아이패드 1개 (그냥 싸고 가벼운거)\n\n- 아이디어\n\n성능좋은 전북대 컴퓨터를 논리적으로 3개로 분리 \\(\\to\\) 이를 각각 (base) (py39jl17) (py38r40) 컴퓨터라고 하자.\n나는 (py39jl17)에 접속하여 파이썬 3.9와 줄리아 1.7을 설치한뒤 실습한다.\n대학원생은 (py38r40)에 접속하여 파이썬 3.8과 R 4.0을 설치하고 실습한다.\n(base)는 예비용으로 아무것도 설치안한 깨끗한 상태 유지\n내가 뭘 실수해서 (py39jl17)컴퓨터가 망가졌으나 (py38r40)은 아무 타격없다.\n나는 (py39jl17)를 삭제하고 (base)로 부터 다시 새로운 컴퓨터를 복사하여 (py39jl17)을 다시 만든다."
  },
  {
    "objectID": "posts/01_PythonBasic/2023-04-03-5wk-1.html#모델3-가상컴퓨터",
    "href": "posts/01_PythonBasic/2023-04-03-5wk-1.html#모델3-가상컴퓨터",
    "title": "05wk-1: 개발환경의 변화",
    "section": "모델3: 가상컴퓨터",
    "text": "모델3: 가상컴퓨터\n- 여러분들 사례\n\n여러분들의 컴퓨터는 (base), (py39) 2개의 컴퓨터로 나누어져 있음\n여러분들이 (py39)에만 주피터랩을 설치\n(py39)에 있는 ipython과 여러분의 크롬창이 서로 통신하면서 실습\n장점: 서로 다른 환경에 서로다른 파이썬과 R등을 설치할 수 있다. \\(\\to\\) 패키지간의 충돌이 최소화 (파이썬 입문 수업을 듣고, 이후에 파이썬을 이용하는 어떤수업을 들음)"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-04-03-5wk-1.html#모델4-클라우드",
    "href": "posts/01_PythonBasic/2023-04-03-5wk-1.html#모델4-클라우드",
    "title": "05wk-1: 개발환경의 변화",
    "section": "모델4: 클라우드",
    "text": "모델4: 클라우드\n- 사례1\n\n성능이 그저그런 컴퓨터 27개\n대학원생을 포함하여 쓸 사람은 5명\n한사람당 27/5(=5.4)대의 컴퓨터식 할당\n\n- 사례2: 구글코랩\n\n구글에 여러가지 성능을 가진 컴퓨터가 \\(n\\)대 있음\n\\(m\\)명의 사람이 \\(n\\)대의 컴퓨터에 접속\n적당히 컴퓨터 자언을 분배하여 사용"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-29-4wk-2.html#key의-조건",
    "href": "posts/01_PythonBasic/2023-03-29-4wk-2.html#key의-조건",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "key의 조건",
    "text": "key의 조건\n- 조건1: 키로 쓸 수 있는 자료형은 정해져 있다.\n\nint O, float O, bool O, str O, list X, tuple O, dict X, set X\n\n(예시1) dict의 키로 int를 사용\n\ndct = {0:[1,2,3], 1:[2,3,4]} \ndct[0] # 인덱싱 하는거 같네?\n\n[1, 2, 3]\n\n\n\ndct[-1] # 속았지?\n\nKeyError: -1\n\n\n(예시2) dict의 키로 float을 사용 <– 이렇게 쓰는 사람 본적이 없어요\n\ndct = {3.14:'π', 2.178:'e'}\ndct[3.14]\n\n'π'\n\n\n(예시3) dict의 키로 bool을 사용\n\ndct = {True: '참이다', False: '거짓이다.'} \ndct\n\n{True: '참이다', False: '거짓이다.'}\n\n\n\ndct[1<2]\n\n'참이다'\n\n\n(예시4) dict의 키로 str을 사용 (\\(\\star\\))\n\ndct = {'guebin':[10,20,30,30], 'hanni':[10,20,25,40]}\ndct['guebin']\n\n[10, 20, 30, 30]\n\n\n(예시5) dict의 키로 list를 사용 \\(\\Rightarrow\\) 불가능\n\ndct = {[10,20,30,40]: 'guebin', [10,20,25,40]: 'hanni'} \ndct\n\nTypeError: unhashable type: 'list'\n\n\n(예시6) dict의 키로 tuple 사용 (\\(\\star\\))\n\ndct = {(10,20,30,40): 'guebin', (10,20,25,40): 'hanni'} \ndct\n\n{(10, 20, 30, 40): 'guebin', (10, 20, 25, 40): 'hanni'}\n\n\n\ndct[(10,20,30,40)]\n\n'guebin'\n\n\n\ndct[10,20,30,40]\n\n'guebin'\n\n\n(예시7) dict의 키로 dict사용 \\(\\Rightarrow\\) 불가능\n\ndct = {{0:1}: 'guebin', {1:2}: 'hanni'} \ndct\n\nTypeError: unhashable type: 'dict'\n\n\n(예시8) dict의 키로 set사용 \\(\\Rightarrow\\) 불가능\n\ndct = {{'샌드위치','딸기우유'}:'점심', {'불고기','된장찌개','김','콩자반'}: '저녁'}\ndct\n\nTypeError: unhashable type: 'set'\n\n\n- 조건2: 키는 중복해서 쓸 수 없다.\n(예시1)\n\ndct = {0:[1,2,3], 1:[2,3,4], 0:[3,4,5]} # 이렇게 쓰지 마세요\ndct \n\n{0: [3, 4, 5], 1: [2, 3, 4]}"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-29-4wk-2.html#value의-조건",
    "href": "posts/01_PythonBasic/2023-03-29-4wk-2.html#value의-조건",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "value의 조건",
    "text": "value의 조건\n- 없다… \\(\\Rightarrow\\) dict는 컨테이너형!!"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-29-4wk-2.html#딕셔너리-컴프리헨션",
    "href": "posts/01_PythonBasic/2023-03-29-4wk-2.html#딕셔너리-컴프리헨션",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "딕셔너리 컴프리헨션",
    "text": "딕셔너리 컴프리헨션\n- 예시1\n\nlst = [['딸기','사과'],['오토바이','자동차'],['컴퓨터','아이패드','마우스']]\nlst  \n\n[['딸기', '사과'], ['오토바이', '자동차'], ['컴퓨터', '아이패드', '마우스']]\n\n\n\n{i:lst[i] for i in range(3)}\n\n{0: ['딸기', '사과'], 1: ['오토바이', '자동차'], 2: ['컴퓨터', '아이패드', '마우스']}\n\n\n- 예시2: key, val을 서로 바꾸는 예시\n\ndct = {'a':(1,0,0,0), 'b':(0,1,0,0), 'c':(0,0,1,0), 'd':(0,0,0,1)}\ndct\n\n{'a': (1, 0, 0, 0), 'b': (0, 1, 0, 0), 'c': (0, 0, 1, 0), 'd': (0, 0, 0, 1)}\n\n\n\n{v:k for k,v in dct.items() }\n\n{(1, 0, 0, 0): 'a', (0, 1, 0, 0): 'b', (0, 0, 1, 0): 'c', (0, 0, 0, 1): 'd'}"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-29-4wk-2.html#바꿔치기-3",
    "href": "posts/01_PythonBasic/2023-03-29-4wk-2.html#바꿔치기-3",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "바꿔치기 (3)",
    "text": "바꿔치기 (3)\n- 예제1: 아래와 같은 리스트가 있다고 하자.\n\nlst = list('abcd'*2)\nlst\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd']\n\n\n아래의 규칙에 의하여 lst의 각 원소의 값을 바꾸고 싶다고 하자.\n\n\n\n변환전\n변환후\n\n\n\n\n‘a’\n[1,0,0,0]\n\n\n‘b’\n[0,1,0,0]\n\n\n‘c’\n[0,0,1,0]\n\n\n‘d’\n[0,0,0,1]\n\n\n\n이를 구현하는 코드를 작성하고, 역변환하는 코드를 작성하라.\nhint: 아래의 dct를 이용할 것\n\ndct = {'a':[1,0,0,0], 'b':[0,1,0,0], 'c':[0,0,1,0], 'd':[0,0,0,1]}\ndct\n\n{'a': [1, 0, 0, 0], 'b': [0, 1, 0, 0], 'c': [0, 0, 1, 0], 'd': [0, 0, 0, 1]}\n\n\n(풀이)\n변환하는 코드를 구현하면\n\nlst2= [dct[l] for l in lst] \nlst2\n\n[[1, 0, 0, 0],\n [0, 1, 0, 0],\n [0, 0, 1, 0],\n [0, 0, 0, 1],\n [1, 0, 0, 0],\n [0, 1, 0, 0],\n [0, 0, 1, 0],\n [0, 0, 0, 1]]\n\n\n역변환하는 코드를 구현하면\n(1단계)\n\ndct_inv = {tuple(v):k for k,v in dct.items()}\ndct_inv\n\n{(1, 0, 0, 0): 'a', (0, 1, 0, 0): 'b', (0, 0, 1, 0): 'c', (0, 0, 0, 1): 'd'}\n\n\n(2단계)\n\n[dct_inv[tuple(l)] for l in lst2]\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd']\n\n\n내생각\n위와 같은 코드는 경우에 따라서 아래와 같은 복잡합 코드를 피할 수 있는 장점이 있다.\n\n[x for l in lst2 for x,y in dct.items() if l==y]\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd']\n\n\n- 예제2: 아래와 같은 리스트가 있다고 하자. – 강의를 재촬영 했습니다.\n\nlst = ['딸기', '사과', '바나나', '바나나', '오토바이', '자동차', '기차']\nlst\n\n['딸기', '사과', '바나나', '바나나', '오토바이', '자동차', '기차']\n\n\n아래와 같은 규칙에 따라서 바꾸고 싶다고 하자.\n\n\n\n변환전\n변환후\n\n\n\n\n딸기\n과일\n\n\n사과\n과일\n\n\n바나나\n과일\n\n\n오토바이\n탈것\n\n\n자동차\n탈것\n\n\n버스\n탈것\n\n\n기차\n탈것\n\n\n\n(풀이1)\n\ndct = {'딸기':'과일', '사과':'과일', '바나나':'과일', \n       '오토바이':'탈것', '자동차':'탈것', '버스':'탈것', '기차':'탈것'}\ndct\n\n{'딸기': '과일',\n '사과': '과일',\n '바나나': '과일',\n '오토바이': '탈것',\n '자동차': '탈것',\n '버스': '탈것',\n '기차': '탈것'}\n\n\n\n[dct[l] for l in lst]    \n\n['과일', '과일', '과일', '과일', '탈것', '탈것', '탈것']\n\n\n(풀이2) – 지난시간에 한 것\n\ndct = {'과일':['딸기','사과','바나나'], '탈것':['오토바이','자동차', '버스', '기차']} \ndct\n\n{'과일': ['딸기', '사과', '바나나'], '탈것': ['오토바이', '자동차', '버스', '기차']}\n\n\n\n[k for l in lst for k,v in dct.items() if l in v]\n\n['과일', '과일', '과일', '과일', '탈것', '탈것', '탈것']\n\n\n(풀이3)\n\n_dct = {l:k for k,v in dct.items() for l in v}\n_dct \n\n{'딸기': '과일',\n '사과': '과일',\n '바나나': '과일',\n '오토바이': '탈것',\n '자동차': '탈것',\n '버스': '탈것',\n '기차': '탈것'}\n\n\n\n[_dct[l] for l in lst]\n\n['과일', '과일', '과일', '과일', '탈것', '탈것', '탈것']"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-29-4wk-2.html#선언",
    "href": "posts/01_PythonBasic/2023-03-29-4wk-2.html#선언",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "선언",
    "text": "선언\n\nwishlist={'notebook','desktop'}\nwishlist\n\n{'desktop', 'notebook'}"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-29-4wk-2.html#원소추출",
    "href": "posts/01_PythonBasic/2023-03-29-4wk-2.html#원소추출",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "원소추출",
    "text": "원소추출\n- 일단 인덱스로는 못합니다.\n\nwishlist={'notebook','desktop'}\nwishlist[0]\n\nTypeError: 'set' object is not subscriptable\n\n\n- 딱히 하는 방법이 없어요.. 그리고 이걸 하는 의미가 없어요.. (원소에 접근해서 뭐하려고??)"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-29-4wk-2.html#원소추가",
    "href": "posts/01_PythonBasic/2023-03-29-4wk-2.html#원소추가",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "원소추가",
    "text": "원소추가\n- 이건 의미가 있음\n\nwishlist={'notebook','desktop'} \nwishlist\n\n{'desktop', 'notebook'}\n\n\n\nwishlist.add('ipad')\nwishlist\n\n{'desktop', 'ipad', 'notebook'}\n\n\n\nwishlist.add('notebook') # 이미 원소로 있는건 추가되지 않음. \nwishlist\n\n{'desktop', 'ipad', 'notebook'}"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-29-4wk-2.html#원소삭제",
    "href": "posts/01_PythonBasic/2023-03-29-4wk-2.html#원소삭제",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "원소삭제",
    "text": "원소삭제\n\nwishlist={'desktop', 'ipad', 'notebook'}\nwishlist\n\n{'desktop', 'ipad', 'notebook'}\n\n\n\nwishlist.remove('notebook')\n\n\nwishlist\n\n{'desktop', 'ipad'}"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-29-4wk-2.html#연산",
    "href": "posts/01_PythonBasic/2023-03-29-4wk-2.html#연산",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "연산",
    "text": "연산\n- in 연산자\n\nwishlist={'desktop', 'ipad', 'notebook'}\nwishlist\n\n{'desktop', 'ipad', 'notebook'}\n\n\n\n'notebook' in wishlist\n\nTrue\n\n\n\n참고로 in연산자는 집합에서만 쓰는것은 아님\n\n- 합집합, 교집합, 차집합\n\nday1 = {'notebook','desktop'}\nday2 = {'notebook','ipad'}\n\n\nday1 | day2 # 합집합\n\n{'desktop', 'ipad', 'notebook'}\n\n\n\nday1 & day2 # 교집합\n\n{'notebook'}\n\n\n\nday1 - day2 # 차집합 \n\n{'desktop'}\n\n\n\nday2 - day1 # 차집합\n\n{'ipad'}\n\n\n- 부분집합\n\nday1 = {'notebook', 'desktop'}\nday2 = day1 | {'ipad'} \n\n\nday1 < day2  # day1는 day2의 부분집합인가? \n\nTrue\n\n\n\nday2 < day1\n\nFalse"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-29-4wk-2.html#집합-특수기능",
    "href": "posts/01_PythonBasic/2023-03-29-4wk-2.html#집합-특수기능",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "집합 특수기능",
    "text": "집합 특수기능\n- 합집합\n\nday1 = {'notebook', 'desktop'}\nday2 = {'notebook','ipad'}\n\n\nday1.union(day2)\n\n{'desktop', 'ipad', 'notebook'}\n\n\n- 나머지 메소드는 스스로 찾아보세요"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-29-4wk-2.html#for문과-set",
    "href": "posts/01_PythonBasic/2023-03-29-4wk-2.html#for문과-set",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "for문과 set",
    "text": "for문과 set\n\nday1 = {'notebook', 'desktop'}\nday2 = {'notebook', 'ipad'}\n\n\nfor i in day1|day2: \n    print(i)\n\nnotebook\nipad\ndesktop"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-29-4wk-2.html#set-컴프리헨션",
    "href": "posts/01_PythonBasic/2023-03-29-4wk-2.html#set-컴프리헨션",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "set 컴프리헨션",
    "text": "set 컴프리헨션\n- 예시1\n\nlst = [1,2,1,1,3,4,5]\n{l for l in lst}\n\n{1, 2, 3, 4, 5}"
  },
  {
    "objectID": "posts/01_PythonBasic/2023-03-29-4wk-2.html#유니크한-원소",
    "href": "posts/01_PythonBasic/2023-03-29-4wk-2.html#유니크한-원소",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "유니크한 원소",
    "text": "유니크한 원소\n- 예제1: 아래의 list는 모두 몇 종류의 문자로 이루어져 있는가?\n\nlst=list('asdfasssdfdsasdfasdfasdfasdf')\n\n(풀이)\n\nset(lst)\n\n{'a', 'd', 'f', 's'}\n\n\n\nlen(set(lst))\n\n4\n\n\n- 예제2: 아래의 txt에서 어떠한 종류의 문자가 각각 몇번씩 사용되었는지 빈도를 구하는 코드를 작성하라.\n\ntxt = 'asdkflkjahsdlkjfhlaksglkjdhflkgjhlskdfjhglkajhsdlkfjhalsdkf'\ntxt\n\n'asdkflkjahsdlkjfhlaksglkjdhflkgjhlskdfjhglkajhsdlkfjhalsdkf'\n\n\n(풀이)\n\n{k:list(txt).count(k) for k in set(txt)}\n\n{'s': 6, 'a': 5, 'g': 3, 'k': 10, 'j': 7, 'h': 7, 'd': 6, 'l': 9, 'f': 6}"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "파이썬 프로그래밍 (2023)",
    "section": "",
    "text": "질문하는 방법\n\n카카오톡: 질문하러 가기 // 학기종료이후 폐쇄함\n이메일: guebin@jbnu.ac.kr\n직접방문: 자연과학대학 본관 205호\nZoom: 카카오톡이나 이메일로 미리 시간을 정할 것\nLMS:\n\n강의노트\n\n\n\n\n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nApr 10, 2024\n\n\n06wk-1: Numpy (1)\n\n\n최규빈\n\n\n\n\nApr 5, 2023\n\n\n05wk-2: 모듈, 패키지, 라이브러리\n\n\n최규빈\n\n\n\n\nApr 3, 2023\n\n\n05wk-1: 개발환경의 변화\n\n\n최규빈\n\n\n\n\nMar 29, 2023\n\n\n04wk-2: 파이썬의 자료형 (7)\n\n\n최규빈\n\n\n\n\nMar 27, 2023\n\n\n04wk-1: 파이썬의 자료형 (6)\n\n\n최규빈\n\n\n\n\nMar 22, 2023\n\n\n03wk-2: 파이썬의 자료형 (5)\n\n\n최규빈\n\n\n\n\nMar 20, 2023\n\n\n03wk-1: 파이썬의 자료형 (4)\n\n\n최규빈\n\n\n\n\nMar 15, 2023\n\n\n02wk-2: 파이썬의 자료형 (3)\n\n\n최규빈\n\n\n\n\nMar 13, 2023\n\n\n02wk-1: 파이썬의 자료형 (2)\n\n\n최규빈\n\n\n\n\nMar 7, 2023\n\n\n01wk-2: 파이썬의 자료형 (1)\n\n\n최규빈\n\n\n\n\nMar 6, 2023\n\n\n01wk-1: 강의소개\n\n\n최규빈\n\n\n\n\nJun 6, 2022\n\n\n참고자료: 2022-06-final\n\n\n최규빈\n\n\n\n\nApr 1, 2022\n\n\n참고자료: 2022-04-mid\n\n\n최규빈\n\n\n\n\nJun 6, 2021\n\n\n참고자료: 2021-06-final\n\n\n최규빈\n\n\n\n\nApr 1, 2021\n\n\n참고자료: 2021-04-mid\n\n\n최규빈\n\n\n\n\n\n\nNo matching items"
  }
]